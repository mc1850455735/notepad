
# 请求映射路径

- 对于两个不同模块中都使用同样的路径作为某个方法的映射路径时, 会出现报错
	- 为了允许不同模块使用相同路径, 可以设置模块名作为请求路径前缀
- 在`@Controller`上添加`@RequestMapping`设置前缀

```java
@Controller  
@RequestMapping("/book")  
public class BookController {  
    @RequestMapping("/save")  
    @ResponseBody  
    public String save() {  
        System.out.println("book save ...");  
        return "{'module':'book save'}";  
    }  
}
```

# 请求参数

### 参数发送

##### Get请求
- 对于get, 其参数可以直接选择直接在地址栏中书写, 也可以在下面的表格中书写
	- 在postman中可以通过勾选选择要传递的参数

![[后端/SSM/02-SpringMVC/Inbox/Pasted image 20250801231807.png]]

##### Post请求
- 对于post, 不应该在Params或者url中添加数据, 而是应该在Body中添加
- 在Body中, 如果想要传输简单的表单数据, 应该使用`x-www-form-urlencoded`
	- `x-www-form-urlencoded` 是轻量、简单的编码方式，适合传字符串
	- `form-data` 是功能更强的编码方式，**可上传文件和结构化数据**。

![[后端/SSM/02-SpringMVC/Inbox/Pasted image 20250801232503.png]]

### 参数接收

对于SpringMvc, 不会区分Get和Post

##### 单个参数
- 如果想要接收参数, 只需要在方法名中书写对应的形参即可
```java
@RequestMapping("/commonParam")  
@ResponseBody  
public String commonParam(String name){  
    System.out.println("name ===> " + name);  
    return "{'module':'common param'}";  
}
```

##### 多个参数
- 对于多个参数, 也只需要多写几个形参即可
```java
@RequestMapping("commonParam")  
@ResponseBody  
public String commonParam(String name, int age) {  
    ... 
    return "'module':'common param'";  
}
```

##### 中文处理
- 直接传输中文时, 可能会出现乱码的情况
- 为在post中接收中文, 需要在`ServletContainersInitConfig`中使用过滤器Filter进行过滤
	- 在get中接收中文相对麻烦, 此处暂不表
- 使用重载方法 `getServletFilters` 进行过滤器的设置
	- 设置字符集过滤器, 将编码方式改为utf-8
	- 过滤器虽然名字叫做过滤器, 但是实际上是对请求参数或相应结果用来预处理的工具, 在此处, 过滤器的作用就是将传入参数的编码方式预处理为utf-8
- 以后写config时, 记得提前写好中文处理的过滤器
```java
@Override  
protected Filter[] getServletFilters() {  
    CharacterEncodingFilter cef = new CharacterEncodingFilter();  
    cef.setEncoding("UTF-8");
    return new Filter[]{cef};  
}
```

##### 参数不同名
- 默认情况下, 只有相同名称的参数才能传递信息
	- 比如get传name, 则springmvc要用名称为name的参数结构
- 如果想要不同名称参数实现信息传递, 那么可以使用注解`@RequestParam("名称")`
	- 该注解有两个参数
	- required : 设置该参数是否为必传参数
	- defaultValue : 设置参数的默认值
```java
@RequestMapping("/commonParamDifferentName")  
@ResponseBody  
public String commonParamDifferentName(@RequestParam("name") String username, int age) {  
    ... 
    return "'module':'common param different name'";  
}
```


### 参数类型

##### 普通参数
(见上文)

##### pojo参数
- pojo, 既Spring中的实体类对象
```java
public class User {  
    private String name;  
    private int age;
    ...
}
```
- 如果传入的属性名和实体类属性名一样, 那么可以自动把传入属性名加入实体类中, 如传入`name=itcast&age=15` , 对于下段代码, 将直接把name和age给参数user
```java
@RequestMapping("/pojoParam")  
@ResponseBody  
public String pojoParam(User user) {  
    System.out.println("pojo参数传递 user ==> " + user);  
    return "'module':'pojo param'";  
}
```

**带pojo的pojo参数**
- 在SpringMVC中正常书写
- 在传参时, 对于pojo中的pojo, 使用嵌套的方式进行传参, 既如果User中有Address, 则对Address中的City传参可以写为address.city

![[后端/SSM/02-SpringMVC/Inbox/Pasted image 20250802014531.png]]

##### 数组参数
- 对于想要传入数组的情况 , 只需要传入多个相同名称的参数, 就会被自动识别为一个数组内的数据

![[后端/SSM/02-SpringMVC/Inbox/Pasted image 20250802015122.png]]

##### 集合参数

- 对于集合参数, 试图直接以类似数组参数方式传参, 会进行报错提示没有对应方法, 缺少的方法为构造方法
- 对于引用类型, 处理态度为新建一个对应类型的对象, 再将这个对象传入
	- 对于List, 应该将对应的数据传入List内部存储, 而不是将传入数据作为List容器的属性(如length)处理
- 所以需要使用 `@RequestParams` 调用构造器, 提醒参数应该直接加入容器而不是作为属性 
- 
```java
@RequestMapping("/listParam")  
@ResponseBody  
public String listParam(@RequestParam List<String> likes) {  
    ...
}
```

![[后端/SSM/02-SpringMVC/Inbox/Pasted image 20250802021138.png]]

### JSON传参

**JSON数据发送**
- 在Postman中选择Body选项, 并在其中选中raw后, 在下拉栏中选择JSON
![[后端/SSM/02-SpringMVC/Inbox/Pasted image 20250802022106.png]]

**JSON数据接收**
1. 在依赖中添加JSON相关组件
```xml
<dependency>  
    <groupId>com.fasterxml.jackson.core</groupId>  
    <artifactId>jackson-databind</artifactId>  
    <version>2.9.8</version>  
</dependency>
```
2. 在SpringMvcConfig 中添加 `@EnableWebMvc` , 即可开启JSON转web pojo的功能
```java
@Configuration  
@ComponentScan("top.majinliang.controller")  
@EnableWebMvc  
public class SpringMvcConfig {  
}
```
3. 在相关方法的参数前添加 `@RequestBody` , 表明相关数据存在请求体中
```java
@RequestMapping("/listParamForJson")  
@ResponseBody  
public String listParamForJson(@RequestBody List<String> likes) {  
    ... 
}
```

##### JSON 数组
(见上)

##### JSON 对象
(同上)

##### JSON POJO 数组
(同上)

**记住凡是使用JSON的都要加@RequestBody**

**@RequestParam和@RequestBody的区别**
- @RequestParam
	- 用于接收url地址传址, 表单传参`application/x-www-form-urlencoded`
- @RequestBody
	- 用于接收Json数据, 表单传参`application/json`
- 后期多使用json发送数据, @RequestBody应用较广, 如果发送非json格式数据, 选用@RequestParam

# 日期类型参数传递

- 日期类型数据具有格式, 根据系统不同, 其格式也各不相同
- 对于常见的几种日期格式, SpringMvc的适配是不同的
- 如果想要设置接受的日期格式, 使用 `@DateTimeFormat` 注解 , 通过给注解的pattern赋值, 来设置其需要匹配的格式
	- 2088/08/08 (yyyy/MM/dd) : Spring默认标准格式, 可以直接接收
		- 对于带时间的格式, 只要使用的是默认标准格式, 就都不用特殊设置
	- 2088-08-08 (yyyy-MM-dd) : 通过指定格式后 , 可以接收
	- 2088-08-08 08:08:08 (yyyy-MM-dd HH:mm:ss) : 同上

```java
// 日期参数  
@RequestMapping("/dataParam")  
@ResponseBody  
public String dataParam(  
        Date date1,   
@DateTimeFormat(pattern = "yyyy-MM-dd") Date date2,   
@DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss") Date date3) {  
    System.out.println("参数传递 date1 ===> " + date1);  
    System.out.println("参数传递 date2 ===> " + date2);  
    System.out.println("参数传递 date3 ===> " + date3);  
    return "{'module':'date param'}";  
}
```

### converter接口

```java
@FunctionalInterface  
public interface Converter<S, T> {  
    @Nullable  
    T convert(S var1);  
}
```

- 日期类型参数转换是通过converter接口定义的, 通过对converter接口的实现, 才能保证外部传入的数据被转为正确的类型
- 例如
	- 请求参数转年龄数据 : String -> Integer
	- 请求参数转日期格式 : String -> Date
- `@EnableMvc` 功能之一 : 根据类型匹配对应的类型转换器 

# 响应JSON数据

### 响应页面
- 将页面名称作为字符串返回 (不加@ResponseBody) , 即可实现跳转页面的功能
```java
@RequestMapping("/toJumpPage")  
public String toJumpPage() {  
    System.out.println("跳转页面");  
    return "page.jsp";  
}
```

### 响应数据

- 如果想要返回字符串或JSON数据等, 不能直接返回字符串, 否则Spring就会试图找一个你想要返回的对应字符串作为文件名的文件
- 如果想要直接返回数据, 需要添加`@ResponseBody`

##### 响应纯文本数据

```java
@RequestMapping("/toText")  
@ResponseBody  
public String toText() {  
    System.out.println("返回纯文本数据");  
    return "response text";  
}
```

##### 响应JSON数据

**响应POJO对象**
- 对于返回pojo对象的情况, 在加入`@ResponseBody`注解的情况下, 直接返回即可自动返回JSON格式
- 记得要添加如 Jackson 等 json 工具来将类转为JSON
```java
@RequestMapping("/toJsonPOJO")  
@ResponseBody  
public User toJsonPOJO() {  
    System.out.println("返回json对象数据");  
    User user = new User();  
    user.setName("itcast");  
    user.setAge(18);  
    return user;  
}
```

**响应POJO集合对象**
```java
@RequestMapping("/toJsonList")  
@ResponseBody  
public List<User> toJsonList() {  
    System.out.println("返回json对象数据");  
    User user1 = new User();  
    user1.setName("majinliang");  
    user1.setAge(18);  
    User user2 = new User();  
    user2.setName("zhuangxiaohan");  
    user2.setAge(18);  
    return new ArrayList<User>(Arrays.asList(user1, user2));  
}
```


### @ResponseBody详解
- 类型 : 方法注解
- 位置 : SpringMVC控制器方法定义上方
- 作用 : 设置当前控制器**返回值为响应体**
	- 如果返回对象, 则会转为JSON再返回
```java
@RequestMapping("/toJsonPOJO")  
@ResponseBody  
public User toJsonPOJO() {  
    ...  
    return user;  
}
```

- 对于转Json的过程, 不由converter接口控制, 而是HttpMessageConverter接口
- 并不是从一个类型到另一个类型, 而是对Http消息进行转换
- 由Jackson实现这个接口, 所以为了实现类型转换, 要引入Jackson坐标
- 源码
```java
public interface HttpMessageConverter<T> {  
    boolean canRead(Class<?> var1, @Nullable MediaType var2);  
    boolean canWrite(Class<?> var1, @Nullable MediaType var2);  
    List<MediaType> getSupportedMediaTypes();  
    T read(Class<? extends T> var1, HttpInputMessage var2) throws IOException, HttpMessageNotReadableException;  
    void write(T var1, @Nullable MediaType var2, HttpOutputMessage var3) throws IOException, HttpMessageNotWritableException;  
}
```

