# 拦截器概念

### 基础概念
- 拦截器(Interceptor)是一种**动态拦截方法调用**的机制, 在SpringMVC中动态拦截控制器方法的执行
- 作用
	- 在指定方法调用前后执行预先设定的代码
	- 阻止原始方法的执行

- 在控制器前和后进行一些控制, 从而达成一些目的
![[后端/SSM/02-SpringMVC/Inbox/Pasted image 20250806015916.png]]

### 拦截器与过滤器区别
- 归属不同 : Filter属于Servlet技术, Interceptor属于SpringMVC技术
- 拦截内容不同 : Filter对所有访问进行增强, Interceptor仅针对SpringMVC的访问进行增强

# 入门案例

### 定义拦截器
- 通常情况下, 拦截器定义在controller包中
- 在controller中定义interceptor包, 并在其中定义拦截器类, 如`ProjectInterceptor` , 实现自接口 `HandlerInterceptor`
- 为使SpringMvcConfig可以扫描到该拦截器, 需要为其添加 `@Component` 注解
- 通过覆盖父类方法, 实现自己的功能
	- `preHandler` : 在拦截的原始操作之前进行操作
	- `postHandler` : 在拦截的原始操作之后进行操作
	- `afterCompletion` : 在拦截操作之后进行的代码, 在post的后面
- `preHandler` 返回false可以**终止原始操作**的运行
```java
@Component  
public class ProjectInterceptor implements HandlerInterceptor {  
    public boolean preHandle(...) throws Exception {  
        System.out.println("preHandle ...");  
        return true;
    }  
    public void postHandle(...) throws Exception {  
        System.out.println("postHandle ...");
    }  
    public void afterCompletion(...) throws Exception {  
        System.out.println("afterCompletion ...");
    }  
}
```

### 拦截器配置
- 通过配置 `SpringMvcSupport` (参考过滤访问资源路径), 指定需要进行拦截的访问路径, 将拦截器和拦截路径联系起来 (如 "/books" )
- 对于该Support, 记得要在 `SpringMvcConfig` 使用 `ComponentScan` 加载配置
```java
@Configuration
public class SpringMvcSupport extends WebMvcConfigurationSupport {  
    @Autowired  
    private ProjectInterceptor projectInterceptor;  
  
    @Override  
    protected void addInterceptors(InterceptorRegistry registry) {  
		    registry
		    .addInterceptor(projectInterceptor)
		    .addPathPatterns("/books");  
    }  
}
```
- 拦截路径设置函数接收一个可变参数, 同时可以使用通配的方式进行匹配 (如 `/books/*` 表示拦截所有`/books`开头的请求)
```java
@Override  
    protected void addInterceptors(InterceptorRegistry registry) {  
		    registry
		    .addInterceptor(projectInterceptor)
		    .addPathPatterns("/books", "/books/*");  
    } 
```

### 拦截器执行流程
- 先执行 `preHandler`
	- 判断是否返回true, 如果为true, 继续向下执行, 否则结束流程
- 开始执行 Controller 相关操作
- 然后执行postHandler
- 最后执行afterCompletion
![[后端/SSM/02-SpringMVC/Inbox/Pasted image 20250806145035.png]]

### 配置类简化开发

- 通过 `SpringMvcConfig` 实现接口 `WebMvcConfigurer` , 就可以将大多数 `SpringMvcSupport` 中实现的功能集成在 `SpringMvcConfig` 中
- 将功能集成在 `SpringMvcConfig` 后, config就不必需要再被扫描, 同时config中也不必再书写 `SpringMvcSupport`
- 缺点是 侵入式较强

# 拦截器参数

- `HttpServletRequest request` : 用户发来的请求参数对象
- `HttpServletResponse response` : 在拦截器中控制的响应结果
- `Object handler` : 被调用的处理器对象, 本质上是一个方法对象, 对反射技术中的Method对象进行了再包装
- `ModelAndView modelAndView` : 封装了页面跳转的相关数据
- `Exception ex` : 内含可能抛出的异常 - 通过SpringMvc提供的异常处理机制替换

```java
public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {  
    ...
}  
  
public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {  
    ... 
}  
  
public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {  
    ...
}
```

# 拦截器链

- 当配置多个拦截器时, 会形成拦截器链
- 拦截器链中, 按照**配置的先后顺序**决定执行的先后顺序
- 先开始的后结束, 后开始的先结束, 遵循先进后出(FILO)的原则
- 无论拦截链顺序, 都是先执行pre, 再执行post, 最后执行after
- 当拦截器链在某个pre中断时, 所有的post均不会运行, 只有执行过且返回true的pre才会执行after

**如图为各个pre返回false的执行情况**
- 黄色为pre3返回false, 蓝色为pre2返回false, 红色为pre1返回false
![[后端/SSM/02-SpringMVC/Inbox/Pasted image 20250806161730.png]]