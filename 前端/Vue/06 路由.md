## 路由进阶

### 路由的抽离
- 问题: 所有的路由配置不应全放在main.js中
- 目标: 将路由模块抽离出来
- 好处: 拆分模块, 便于维护

**步骤**
- 新建router文件夹
	- 将路由配置挪到router中index.js中
- 在index.js中要记得重新导入vue

**技巧**
- 使用 `@` 表示从src开始的路径

**示例**

```js
import VueRouter from 'vue-router'
import Vue from 'vue'

import Find from '@/views/Find.vue'
import Friend from '@/views/Friend.vue'
import My from '@/views/My.vue'

Vue.use(VueRouter);
const router = new VueRouter({
  routes: [
    { path: '/find', component: Find },
    { path: '/friend', component: Friend },
    { path: '/my', component: My }
  ]
});

export default router;
```

### 声明式导航

- 需求: 实现导航高亮
- vue-router提供了一个全局组件router-link取代a标签
  1. 能跳转: 用to属性指定路径(必须), 本质还是a标签 (无需使用`#`)
  2. 能高亮: 默认就会提供**高亮类名**, 可以直接设置高亮样式
     - 通过添加`router-link-active`类和`router-link-exact-active`类来实现导航高亮
     - 当前所在地址对应的`router-link`会默认添加这两个类

**两个类名的区别**

- `router-link-active` : 模糊匹配(用的多), 用来匹配以特定路径地址开头的路径
- `router-link-exact-active` : 精确匹配(用的少), 只能用来匹配特定的路径名

**自定义类名**	

- 在VueRouter对象中定义`linkActiveClass`和`linkExactActiveClass`两个属性, 即可自定义这两个类名
  - 直接敲link就能联想出来
```js
const router = new VueRouter({
  routes: [
    { path: '/find', component: Find },
    { path: '/friend', component: Friend },
    { path: '/my', component: My }
  ],
  linkActiveClass: 'active',
  linkExactActiveClass: 'exact-active'
});
```

### 跳转传参

- 目标: 在跳转时进行传参
1. 查询参数传参
    - 语法格式: `to="path?参数名=值"`
     - 对应页面组件接收传过来的值: `$route.query.参数名`
     - 模板中可以省略 this, 在函数中使用必须加上 this

 ```html
 <router-link to="/search?words=黑马程序员">黑马程序员 </router-link>
 <router-link to="/search?words=前端培训">前端培训 </router-link>
 <router-link to="/search?words=如何成为前端大牛">如何成为前端大牛</router-link>
 ```
 ```js
 created() {
	console.log(this.$route.query);
 },
 ```

2. 动态路由传参
	- 在router配置的地址中加入 `/:参数` 的方式来代表动态路由
		- 动态路由可以匹配多个路径
	- 导航链接: `to="/path/参数值"`
	- 对应页面组件接收传递过来的值 => `$route.params.参数名`

```html
<router-link to="/search/黑马程序员">黑马程序员 </router-link>
<router-link to="/search/前端培训">前端培训 </router-link>
<router-link to="/search/如何成为前端大牛">如何成为前端大牛</router-link>
```
```javascript
const router = new VueRouter({
	routes: [
		{ path: '/home', component: Home },
		{ path: '/search/:words', component: Search }
	]
})
created() {
		console.log(this.$route.params);
},
```

**动态路由参数可选符**

- 问题: 如果配置为如`'/search/:words'`的路由, 当传参时, 会出现无法匹配到组件的错误
- 原因: `'/search/:words'`表示必须要传一个名为word的参数
- 如果希望不传参也可以进行对应的匹配, 需要在参数后添加`可选符?`
- 如: `'/search/:words?'`

3. 区别
	1. 查询参数传参 => 比较适合传多个参数
		- 跳转: `to="path?参数名1=值1&参数名2=值2"`
		- 获取: `$route.query.参数名`
	2. 动态路由传参 => 更加简洁, 适合**单个参数**
		- 配置动态路由: `path: "/path/参数名"`
		- 跳转: `to="/path/参数值"`
		- 获取: `$route.params.参数名`

### 重定向/404/模式

**路由重定向**
- 问题: 网页打开时默认为`/`路径, 未匹配到组件时会出现空白
- 重定向功能: 配置到path1后, 强制跳转path2路径
- 语法: `{path: 匹配路径, redirect: 重定向到的路径}`

**路由404**
- 作用: 当路径找不到匹配页面时, 给个提示页面表示没有找到
- 位置: 配在路由的最后位置
- 语法: `path: "*"` (表示对任意路径的匹配) -> 如果前面的都不匹配, 就命中最后这个

**模式设置**

- 两种路由模式
	- hash路由(默认) -> `localhost:8080/#/home`
	- history路由(常用) -> `localhost:8080/home` (以后上线需要服务端的支持)
- 区别: 底层实现不同
	- hash: 基于a标签锚链接跳转实现
	- history: 基于html5新增的的historyAPI实现

- 切换history: 在router声明中添加`mode: 'history'`
- 采用history模式要告知后端,  对后端影响较大
- 需要后台配置url访问规则
```js
const router = new VueRouter({
  routes: [ /* 路由相关信息 */ ],
  mode: 'history'
})
```

### 编程式导航

#### 基本跳转

- 使用JS代码实现点击按钮进行跳转
	- 由于是单页应用程序, 因此不能通过location.href等方式进行跳转
- 两种语法
	- path路径跳转 : 简易方便
	- name命名路由跳转 : 适合path路径较长的情景

**path路径跳转**
- 简写: `this.$router.push('路由路径')`
- 完整写法 (更适合chuan): `this.$router.push({path: '路由路径'})`

**name命名路由跳转**
1. 在路由定义中声明路由名称
2. 使用`this.$router.push({name: '路由名称'})`
```js
// 配置
const router = new VueRouter({
  routes: [
    // 为路由添加名称
    { name: 'search', path: '/search/:words?', component: Search },
  ],
})

// 使用
this.$router.push({
    name: "search",
});
```

**返回上一页**
- `$router.back()`

#### 路由传参

- 两种传参方式: 查询参数 + 动态路由传参
- 两种跳转方式, 对于两种传参方式都支持

**path路径跳转传参**
- query传参
```js
// 简写
this.$router.push(`/search?words=${this.words}`);
// 完整写法
this.$router.push({
    name: "search",
    query: {
        words: this.words,
    },
});
```

- 动态路由传参
```js
// 简写
this.$router.push(`/search/${this.words}`);
// 完整写法
this.$router.push({
    path: `/search/${this.words}`,
});
```

**name命名路由跳转传参**
- query传参 => 只能使用完整写法传参
- 动态路由传参 => 使用params参数传参
```js
this.$router.push({
    name: "search",
    params: {
        words: this.words,
    },
});
```


### 多级路由

- 先配置路由, 再去实现功能
- 通过children配置项, 可以用来配置嵌套子路由
- 步骤
	1. 设置children配置项
	2. 准备二级路由出口
```js
routes: [
    {
        path: '/layout',
        component: Layout,
        children: [
            { path: '/collect', component: Collect },
        ]
    },
],
```

### 组件缓存
- 使用keep-alive将使用过的组件缓存下来
- 什么是keep-alive
	- 它是Vue的内置组件, 当他包裹动态组件时, 会缓存不活动的组件实例, 而不是销毁它们
	- keep-alive是一个抽象组件, 它自身不会渲染成为一个DOM元素, 也不会出现在父组件链中
- 优点: 
	- 在组件切换过程中, 把切换出去的组件保留在内存中, 防止重复渲染DOM
	- 减少加载时间及性能消耗, 提高用户体验

- keep-alive属性: 使用过程中可能只需要部分缓存, 而部分不需要缓存
	- include: 组件名数组, 只有匹配的组件才会被缓存 (最常用)
	- exclude: 组件名数组, 任何匹配的组件都不会被缓存 (容易出现性能问题, 配合max使用)
	- max: 最多可以缓存多少组件实例
```js
<keep-alive :include="['LayoutPage']">
    <router-view></router-view>
</keep-alive>
```

- 生命周期: 被缓存的组件会多出来两个生命周期钩子
	- active: 激活, 组件被看到时触发
	- deactive: 失活, 离开页面, 组件看不见时触发
- 组件缓存后, 就不会执行created, mounted等钩子了
```js
activated() {
    alert("welcome");
},
```
