## 指令补充

### 指令修饰符

- 通过 `.` 来指明的指令后缀, 通过后缀封装了不同操作处理
- 按键修饰符
	- `@keyup.enter` -> 键盘回车监听
	- 相当于使用了代码 (`fn(event)`)
```js
<input 
	@keyup.enter="add" //检测enter按键输入
	type="text" 
	placeholder="请输入内容" 
	v-model="content">
</input>
```
- v-model修饰符
	- `v-model.trim` -> 去除首尾空格
	- `v-model.number` -> 转数字
- 事件修饰符
	- `@事件名.stop` -> 阻止冒泡
	- 相当于js中的`stopPropagation()`
```js
<div class="father" @click="fatherFn()">
	<div class="son" @click.stop="sonFn()">
		冒泡
	</div>
</div>
```
- 
	- `@事件名.prevent` -> 阻止默认行为
```js
<a  href="https://www.baidu.com" 
	@click.prevent="preventFn()">
	百度
</a>
```


### v-bind对样式操作

- 作用
	- 为了方便开发者进行样式控制, Vue拓展了v-bind的语法, 可以针对`class类名`和`style行内样式`进行控制

#### 操作class

- 语法: `:class="对象/数组"`
	- 对象: 键就是类名, 值是布尔值, 当布尔值为true时, 表示有这个类, 否则没有这个类
	- `<div :class="{类名1: 布尔值, 类名2: 布尔值}"></div>`
		- 使用场景: 一个类名, 来回切换
	- 数组: 数组中存储类名**字符串**, 数组中有的元素即为当前元素的类
	- `<div class="['类名1', '类名2', ...]"></div>`
		- 使用场景: 批量添加/删除类

#### 操作style

- 语法: `:style="样式对象"`
	- `<div class="box" :style="CSS属性名1: CSS属性值1, CSS属性名2: CSS属性值2, ...">`
- 在样式对象中, 诸如`background-color`不能被直接书写, 应该写成`'background-color'` 或 `backgroundColor`
- 强大之处在于对元素属性的直接操控

### v-model应用于其他表单

- 常见的表单元素都可以用v-model绑定关联
- 用于快速**获取**或**设置**表单元素的值
- 会根据控件类型自动选取正确的方法更新元素

**可用列表**
- 输入框 `input:text` ->value
- 文本域 `textarea` -> value
- 复选框 `input:checkbox` -> checked
	- v-model绑定的变量是数组, 可以收集checkbox的value属性
		- 将复选框的值设置为提前指定好的(如字符串等)
		- 然后将v-model与一个数组相连
		- 当复选框被选中时, 就会将对应的value加入数组
		- 数组中元素被删除时, 对应复选框的状态也会发生变化
- 单选框 `input:radio` -> checked
	- 需要给对应的value添加对应的值
	- 对同一组radio, 添加v-model并绑定到同个变量, Vue通过v-model的值自动选择对应value的radio
```js
<label><input v-model.number="genderCode" type="radio" name="gender" value="1" />男</label>
<label><input v-model.number="genderCode" type="radio" name="gender" value="0" />女</label>
```
- 下拉菜单 `select` -> value
	- 在`option`中设置value值
	- `select`的value值关联了选中的`option`的value值, 二者是相同的
	- 从`select`的v-model中获取选中的option的value
```js
<select v-model="cityCode">
	<option value="101">北京</option>
	<option value="102">上海</option>
	<option value="103">广州</option>
</select>
```

## computed计算属性

- 基于现有的数据, 计算出来的新属性
- 依赖的数据发生变化, 重新进行计算

### 基础语法

- 声明在computed配置项中, 一个计算属性对应一个函数
- 使用起来和普通属性一样使用 `{{计算属性名}}`
- 可以看作对一段求值代码进行的封装
```js
computed: {
	total() {
		return this.list.reduce((sum, item) => sum + item.num, 0)
	}
}
```

- 数组求和函数`reduce(求和逻辑, 计算起始值)`
	- 求和逻辑 `(sum,item) => sum + item.num`

### 与methods的比较

**比较**
- 计算属性
	- 作用: 封装一段对于数据的处理, 求得一个结果
	- 语法:
		- 写在computed配置项中
		- 作为属性直接使用
- methods方法
	- 作用: 给实例提供一个方法用以处理业务逻辑
	- 语法
		- 写在methods配置项中
		- 作为方法, 需要通过调用 `方法名()` 的方式进行使用

**computed的优势**
缓存特性: 
- 计算属性会对计算出来的结果进行缓存, 再次使用时直接读缓存
- 依赖项变化以后, 会自动进行重新计算, 并再次缓存
- 从而提升了程序的性能

### 完整写法

- 一般情况下只用简写即可, 只有需要修改计算属性时, 才会需要使用完整写法
- 计算属性的默认写法是一种简写, 只能进行访问, 不能进行**修改**
- 对于计算属性的完整写法, 应该将计算属性写作一个对象, 在对象中分别设置get方法和set方法

```js
fullName: {
	get() {
		return value
	},
	set(newValue) {
		// newValue为赋给计算属性的值
	}
}
```

- 如果没有set方法而直接对计算属性赋值, 那么将报错

## watch监听器

- 作用: 监视数据变化, 执行一些业务逻辑或异步操作
- 语法: 
	- 简单写法: 简单类型数据, 直接监视
	- 完整写法: 额外添加配置项

### 基础语法

 - 监视普通变量
	 - ` 对象名(newValue){} `
- 监视对象内变量
	- ` '对象名.变量名'(newValue) {}`

### 完整写法

- 额外添加配置项
	- deep:true -> 对复杂类型深度监视
	- immediate: true -> 初始化立即执行一次handler方法
	- handler -> 用于处理的函数名只能为handler, handler中的所有参数都是修改后的监听项

```js
watch: {
	// 对obj进行深度监视
	obj: {
		deep: true,
		handler(ss, ww) {
			console.log('obj变化了', ss, ww);
		}
	},
}
```

