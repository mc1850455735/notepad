### 电商购物业务流
- 自定义项目初始化 -> 需要 vuex, babel, router, css, linter, hash模式
- 目录改造 => 将创建出来的目录调整为符合企业规范的目录
	- 删除多余文件
	- 修改 路由配置和App.vue
	- 新增目录 api & utils
		- api : 接口模块, 封装发送ajax请求的接口模块
		- utils : 工具模块, 封装自己的一些工具方法模块

![[./Inbox/Pasted image 20250118132411.png]]

### 组件库vant
- 第三方vue ui库 - vant-ui
	- **第三方**封装了很多组件, 整合到一起形成一个组件库
	- [介绍 - Vant 3](https://vant-ui.github.io/vant/v3/#/zh-CN/home)
- vue组件库有很多不同的选择, 不只有vant
	- PC端: element-ui 支持Vue2 (element-plus 支持Vue3); ant-design-vue
	- 移动端: vant-ui(更新效率最高); Mini UI; Cube UI
- 安装vant - `npm i vant@latest-v2 -S`
	- 如果安装失败, 尝试更改版本 -> `eslint-plugin-vue@7.20.0`
- 引入组件
	- 按需引入(推荐) => 自动 & 手动
		- 手动 -> `import Button from 'vant/lib/button'; import 'vant/lib/button/style'`
	- 全部引入
		- ( 在`main.js`中 ) `import Vant from 'vant'; import 'vant/lib/index.css'; Vue.use(vant);`
	- 区别: 
		- 全部导入 => 优点: 方便; 缺点: 导致工程体积大, 降低性能
		- 按需引入 => 优点: 性能高; 缺点: 开发较繁琐
- 自动按需导入
	1. 安装插件`babel-plugin-import -D` 
	2. `babel.config.js中配置` -> 见官网
	3. main.js中按需导入 -> `import { Button } from 'vant'; Vue.use(Button)`
	4. 代码中使用
- 通常会把按需导入相关代码进行抽出, 将其作为一个单独的js文件放入utils中
	- vant-ui.js

### 移动端vw适配
- 基于postcss插件, 实现vw适配
	- 同样可以在vant官网找到使用示例
- 可以实现量出来是多少px就写多少px, 最终由插件转换为vw
	- 配置项中写标准屏宽度, iphonex为350
	- 标准屏宽度为 实际尺寸宽度 / 2
1. 安装插件 - `npm i postcss-px-to-viewport@1.1.1 -D`
2. 根目录新建`postcss.config.js`, 填入配置

### request请求方法封装
- 通常会将axios请求方法封装到request模块
	- 在utils文件夹中
- 因为一般会对axios进行一些配置, 比如基础地址, 请求响应拦截器等
- 故而会将axios封装到单独的request模块中以方便维护使用

**步骤**
1. 安装axios
2. 在utils新建request.js
3. 创建对应axios实例 (创建方法参见官方教程)
	- 好处: 不会污染原始axois实例, 方便不同基地址的访问
4. 配置请求/响应拦截器
5. 导出配置好的实例

**图形验证码**
- 图形验证码本质就是一个请求回来的图片
- 用来部分抵御机器自动化攻击
- 实现
	- 动态渲染请求回来的base64格式图片
	- 点击验证码图片盒子, 刷新验证码
- 注意
	- 后台既需要验证码的code来验证用户输入的验证码是否正确
	- 也需要验证码的key来找到对应的验证码

**Base64格式图片使用**
- 直接将Base64编码赋给Url, Url会自动解析图片

### storage存储模块封装

**Vuex持久化处理**
- 封装storage存储模块, 利用本地存储, 进行vuex持久化开发
- 在utils中新建storage.js, 在其中提供方法
	- 约定通用键名, 简化书写
	- `getInfo` : 从本地存储中获取, 不存在则返回空值
	- `setInfo` : 通过传入的值重置对应的值(记住要序列化)
	- `removeInfo` : 从浏览器中移除个人信息

### api请求模块封装
- 将请求封装成方法, 统一存放在api模块, 与页面分离
	- api模块: 存放封装好的请求函数
- 优点: 
	- 请求和页面逻辑分离, 提高程序可阅读性
	- 对于相同请求实现复用
	- 统一管理各个请求
- 步骤
	- 新建请求模块
	- 封装请求函数
	- 页面中导入调用

### 请求响应拦截器

**请求时统一loading效果**
- 在用户或服务器可能由于网络问题出现延时时, 给予用户提示
- 优点
	- 节流处理 : 防止用户在一次请求返回前多次点击(禁止背景点击), 发送无效请求, 增加服务器负担
	- 提示用户 : 告知用户正在加载, 提高用户体验
- 每次请求, 在请求拦截器中打开loading
- 每次响应, 在响应拦截器中关闭loading

**响应拦截器统一处理接口错误提示**
- 响应拦截器是拿到数据的第一个数据流转站, 可以在里面**统一处理错误**
- 实现: 应用时只考虑正确的情况, 错误情况由响应拦截器进行处理
	- 当错误时, 抛出异常后, 代码不会继续向下运行, 从而达到截止错误结果, 只保留正确结果的效果
- 在响应拦截器中检测响应的状态码, 不为200的, 进行特殊处理
	- 使用toast展示对应的错误提示
	- 抛出`Promise.reject(res.message)`
	- 在用户界面与控制台中同时显示错误信息

### 嵌套路由配置
**一级路由**
- 但凡是单个页面独立展示的, 都是一级路由
![[前端/Vue/Inbox/Pasted image 20250118164402.png]]
- 新建页面时, 由于页面可能越来越大, 每个一级模块应该新建成为一个文件夹
	- 先架一级路由, 等写到对应的二级路由时再新建对应的文件
	- 如果路由中加载的是文件夹下的index.js根文件, 那么只需要写对应的文件夹的名称即可

**二级路由配置**
- 配置二级路由
- 配置导航链接
- 配置路由出口

### 路由导航守卫

- 对于某些需要登录才能进行的操作, 对其进行提示并跳转到登录界面
- 对于某些必须登录的用户才能访问的页面, 对游客进行拦截

**全局前置守卫**
- 所有的路由一旦被匹配到, 都会先经过全局前置守卫
- 只有全局前置守卫放行, 才会真正解析渲染组件, 看见页面内容
- 全局前置守卫按照创建顺序调用, 只有全部通过守卫, 才能进入页面
- 拦截与放行的关键点是用户是否有**登录权证token**

**三个关键**
- to : 到哪去
- from : 从哪来
- next : 规则

```js
// 1. to:     去哪里
// 2. from:   来自哪里
// 3. next(): 是否放行
router.beforeEach((to, from, next) => {
	// 放行
	next()
})
```

### 路由跳转传参

### vuex分模块管理

**User模块**
- token存入vuex好处 => 易获取, 响应式
- vuex需要分模块 -> user模块



### 项目打包&优化


### 其他
- 正则测试 => `/^正则表达式$/.test(要测试的变量)`
- Toast 轻提示
	- 可以用在组件内和组件外 : `import`后`Toast`的方法
	- 只能用在组件内: `this.$toast()`
- Toast默认是单例模式, 后面的Toast调用了, 会将前一个Toast覆盖











