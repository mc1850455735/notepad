## 组件三大组成部分

#### scoped样式冲突

- 全局样式(默认) : 组件中的样式会影响所有组件, 容易造成组件之间样式冲突
- 局部样式: **scoped**下样式, 使样式只作用于当前组件
	- 组件应该有自己独立的样式, 推荐加上scoped

**原理**
1. 给当前模板内所有元素都添加上一个自定义属性(data-v-hash值), 不同组件的hash值不同
2. CSS选择器后面被自动处理, 添加上了属性选择器(`div[data-v-hash值]`)
3. 最终效果: 必须是当前组件的元素, 才会有这个自定义属性, 从而被这个样式作用到

#### data是一个函数

- el根实例独有
- data是一个**函数**, 用以保证每个组件实例维护**独立的**一份数据对象
- 每次创建新的组件实例, 都会**新执行**一次data函数, 得到一个新对象
- 不同组件之间的值互不干扰

## 组件通信

- 组件通信, 就是指组件与组件之间的数据传递
- 组件的数据是独立的, 无法直接访问其他组件的数据
- 想用其他组件的数据, 就要进行组件通信

#### 组件通信语法

**组件关系分类**
- 父子关系
	- props和$emit
- 非父子关系
	- provide & inject
	- eventbus
- 通用解决方案
	- vuex -> 适合复杂业务场景

#### 父传子

- 父组件通过props将数据传递给子组件
- 什么是prop
	- prop定义: 组件上注册的一些自定义属性
	- prop作用: 向子组件传递数据
- 特点
	- 可以传递任意数量的prop
	- 可以传递任意类型的prop

**props校验**
- 作用: 为组件的prop指定验证要求, 不符合要求, 则在控制台中出现错误提示 -> 帮助开发者快速发现错误
- 将数组写法改为对象写法 / 对象中包对象
- 语法: 
	- 类型校验 => type
		- 校验的属性名: 类型
	- 非空校验 => required
	- 默认值 => default
	- 自定义校验 => validator(value)

```js
props: {
    w: Number,
},
```
```js
props: {
  w: {
    type: Number,
    required: true,
    default: 50,
    validator(value) {
      // 校验传入的值是否大于等于0, 小于等于100
      return value >= 0 && value <= 100;
    },
  },
},
```

*下面的代码中myTitle作为props被传递给子组件*
```html
<MyItem :title="myTitle"></MyItem>
```

**子组件的接收办法**
- 使用props进行接收
```js
export default {
  props: ["title"],
};
```

**prop & data**
- 共同点: 都可以给组件提供数据
- 区别: 
	- data的数据是自己的 => 随便改
	- prop的数据是外部的 => 不能直接改, 要遵循**单向数据流**
- 想要修改时, 必须使用子传父的方式
- 谁的数据谁负责

*单向数据流*
- 父组件的prop更新, 会单项的向下流动, 进而影响到子组件

#### 子传父

- 子组件利用$emit通知父组件修改更新
- 通过$emit发生事件, 并使用父组件接收事件

**子组件**
```js
changeFn() {
	this.$emit("changeTitle", "new title");
},
```

**父组件**
- handleChange函数的参数即为newTitle值
- 不能加括号, 一旦加括号, 就接收不到返回的对应的值
```html
<SonItem :title="title" @changeTitle="handleChange"></SonItem>
<script>
export default {
  methods: {
    handleChange(newTitle) {
      this.title = newTitle;
    },
  },
};
</script>
```

#### 非父子

##### event bus 事件总线
- 作用: 非父子组件之间, 进行简易的消息传递
	- 复杂场景使用vuex
1. 创建一个都能访问到的事件总线(空Vue实例)
	- utils/EventBus.js
2. 接收方监听Bus实例的事件
	- `Bus.$on('sendMsg', 函数)`
3. 发送方触发Bus实例的事件
	- `Bus.$emit('sendMsg', 消息)`

**事件总线的定义**
```js
// 1.创建一个空的都能访问到的Vue实例
import Vue from 'vue'
const eventBus = new Vue();
export default eventBus;
```

*总线方式是多对多的消息模式*

##### provide&inject
- 作用: **跨层级**共享数据
- 爷爷辈提供数据, 孙子辈就能直接接收
- 简单类型传递的是非响应式的, 也就是说, 即使爷组件中的简单类型修改, 孙组件中也不会发生变化
- 故而推荐使用复杂类型进行跨层级通信

1. 父组件provide提供数据
```js
export default {
  provide() {
    return {
	  // 普通类型[非响应式]
	  color: this.color,
	  // 复杂类型[响应式]
	  userInfo: this.userInfo	
    }
  }
}
```
2. 子孙组件inject取值使用
```js
export default {
  inject: ['color', 'userInfo'],
  created(){
    console.log(this.color, this.userInfo);
  }
}
```


## 进阶语法

#### v-model原理

- 原理
	- v-model本质上就是一个语法糖, 是value属性和input事件的合写
- 作用: 提供数据的双向绑定
	- 数据变, 视图跟着变`:value`
	- 视图变, 数据跟着变`@input`
- 注意: `$event`用在模板中用于获取事件的形参
	- 直接写e无法获取到形参

*示例代码*
```html
<input v-model="msg">
等价于
<input 
  :value="msg"
  @input="$event.target.value">
>
```

#### v-model应用于组件

##### 表单类组件封装
- 父传子: 数据 由父组件props传递而来, v-model拆解绑定数据
- 子传父: 监听输入, 子传父传值给父组件修改

##### v-model简化代码
- 子组件中: props通过value接收传来的值, 事件要触发的事件名固定为input
- 父组件中: v-model给组件直接绑数据

#### sync修饰符

- 作用: 实现子组件与父组件之间的**双向数据绑定**, 简化代码
- 特点: prop属性名可以自定义, 不需要固定为value
- 场景: 使用value可能导致可读性降低
- 本质: 就是`:属性名`和`@update:属性名`合写
	- `:visible.sync` => `:visible + @update:visible`

#### ref和$refs

- 作用: 利用ref和$refs用于获取dom元素或组件实例
- 特点: 查找范围在当前组件内(更加精确稳定)
	- 与querySelector的查找整个页面的查找范围是不同的

**获取dom**
1. 目标标签添加ref属性
2. 恰当时机, 通过`this.$refs.xxx`获取目标标签
	- 至少mounted之后

```HTML
<div ref="baseChartBox"></div>
<script>
const myChart = echarts.init(this.$refs.baseChartBox);
</script>
```

**获取组件**
1. 目标组件, 添加ref属性
2. 恰当时机, 使用this.$ref.xxx获取目标组件, 调用组件对象中的方法
	- 组件对象中含有其methods中的方法函数

```HTML
<div ref="baseChartBox"></div>
<script>
const myChart = echarts.init(this.$refs.baseChartBox);
</script>
```

 **echarts渲染的注意事项**
- 用于渲染的盒子必须要有宽和高
- 脚手架环境下, 使用echarts需要事先安装, 使用
	- `npm install echarts`
`
#### 异步更新与$nextTick

- Vue的代码是异步更新的, 待当前的代码全部执行完后再去更新DOM, 其目的是提升性能
- 可以使用setTimeout函数, 将延时值设置为0, 以达到将对应操作加入异步队列, 从而在dom异步更新完毕后再尝试进行dom操作
- 或者配合$nextTick

**$nextTick**
- 使用: `this.$nextTick(函数体)`
```js
this.$nextTick(() => {
  this.$refs.inp.focus();
});
```

