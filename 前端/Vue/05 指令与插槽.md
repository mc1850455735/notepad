## 自定义指令

#### 基本语法

- 每个指令有着自己各自独立的功能
- 封装一些DOM操作, 拓展额外功能

**语法**
- 全局
- inserted表示当前元素被添加到页面上时, 执行对应的操作
- el表示绑定了该指令的元素
```js
Vue.directive('指令名', {
  "inserted" (el) {
    el.focus();
  }
})
```
- 局部
```js
directives: {
  "指令名": {
    inserted() {
      el.focus();
    }
  }
}
```

- 使用: v-指令名

**其他的生命周期**
- bind : 指令第一次绑定到元素时调用, 一般用于初始化设置
- inserted : 元素插入附件点时调用
- update: 元素更新时调用


#### 指令的值

- 语法: 在绑定指令时, 可以通过"等号"的形式为指令绑定**具体的参数值**
- 通过binding.value拿到指令值, 指令值的**修改**会触发update函数

```html
<p v-color="color1">测试binding -- 01</p>
<script>
inserted(el, binding) {
  el.style.color = binding.value;
},
update(el, binding) {
  // 当vue中变量更新后
  el.style.color = binding.value;
},
</script>
```

## 插槽

**分类**
- 默认插槽
	- 组件内定制一处结构
- 具名插槽
	- 组件内定制多处结构

#### 默认插槽

- 作用: 让组件内部的一些**结构**支持**自定义**
- 基本语法
	1. 将组件内需要定制的部分改为`<slot></slot>`占位
	2. 使用组件时, 组件标签内部的结构替换slot

#### 后备内容

- 给插槽一个默认值
- 插槽后备内容: 封装组件时, 可以为预留的`<slot>`插槽提供后备内容, 即默认内容
- 在`<slot>`标签内放置内容, 其中的内容作为插槽的默认内容
- 外部使用组件不传东西时, slot显示后备内容

#### 具名插槽

- 问题: 只使用默认slot, 多处区域只能使用相同的文字
- 需求: 一个组件内有**多处结构**, 需要外部传入标签, 进行定制
- 语法:
	- 多个slot使用**name属性**区分名字
	- `template`配合`v-slot:名字`分发对应标签
	- 简写: `v-slot:插槽名` 可以简化为 `#插槽名`
- 注意
	- 一旦插槽起了名字, 就是具名插槽, 只支持**定向分发**

**声明具名插槽**
```html
<div class="dialog">
	<div class="dialog-header">
		<slot name="header"></slot>
	</div>

	<div class="dialog-content">
		<slot name="content"></slot>
	</div>
	
	<div class="dialog-footer">
		<slot name="footer"></slot>
	</div>
</div>
```

**使用具名插槽**
```html
<!-- 使用 Dialog 组件 -->
<MyDialog>
	<template #header>
		<div>这是 Dialog 的标题</div>
	</template>
	<template #content>
		<div>这是 Dialog 的内容</div>
	</template>
	<template #footer>
		<button>取消</button>
		<button>确定</button>
	</template>
</MyDialog>
```

#### 作用域插槽

- 是插槽的一个传参语法
- 定义slot插槽的同时是可以传值的
	- 给插槽上可以**绑定数据**, 将来使用组件时可以使用
- 当组件调用者需要用到组件内部的数据时, 通过作用域插槽传值绑定, 进而使用

**使用步骤**
1. 给slot标签以添加属性的方式传值
```html
<slot :id="item.id" msg="test"></slot>
```
2. 所有被添加的数据, 都会被收集到一个对象中(无论是动态数据还是静态的)
```json
{ id: 3, msg: 'test'}
```
3. 在template中, 通过`#插槽名 = "obj"`接收, 默认插槽的插槽名为`default`
	- 默认传来的值为obj, 里面存有slot的各个属性值
	- 可以使用`#插槽名 = "{ row }"`等操作对传来的值**直接进行解构**

**使用示例**
```html
<MyTable :data="list">
		<template #default="obj">
			<!-- 从obj整体中获取传来的数据 -->
			<button @click="del(obj.item.id)">删除</button>
		</template>
	</MyTable>
	<MyTable :data="list2">
		<template #default="{ item }">
			<button @click="show(item)">查看</button>
		</template>
	</MyTable>
```

## 路由入门

#### 单页应用程序
- SPA: Single Page Application
- 特点: 所有功能在**一个html**上实现

**区分**
- 单页
- 系统类/内部网站/文档类/移动端站点
	- 一个html页面
	- **按需更新**, 性能高
	- 开发效率高
	- 用户体验好
	- 开发效率高
	- 用户体验好
	- 首屏加载**速度慢**
	- SEO效果差
- 多页
- 公司官网/电商类网站
	- 多个html页面
	- 整页更新, 性能低
	- 开发效率中等
	- 用户体验一般
	- 学习成本一般
	- 首屏加载速度快
	- SEO效果好

#### 路由概念

- 要实现按需更新, 就必须首先明确, **访问路径**和**组件**的对应关系
- 关系确定方式: 路由

**概念**
- 路径和组件之间的映射关系

#### VueRouter基本使用

- 作用: 
	- 修改地址栏路径时, 切换显示匹配的组件
- 说明: 
	- Vue官方提供的路由插件, 一个第三方包

**使用过程**
- 固定五步
1. 下载: 下载VueRouter模块到当前工程(V2对应版本v3.6.5)
	- 口诀: `233, 344` 
	- Vue2安装VueRouter和Vuex为3.x版本
	- Vue3安装VueRouter和Vuex为4.x版本
	- `npm install vue-router@3.6.5`
2. 引入
	- `import VueRouter from 'vue-router'
3. 安装注册
	- `Vue.use(VueRouter)`
4. 创建路由对象(空)
	- `const router = new VueRouter()`
5. **注入**, 将路由对象注入new Vue实例中, 建立关联
	- `router: 路由对象名`
	- 路由对象名 = router时, 可以简写
```js
new Vue({
	render: h=>h(App),
	router
}).$mount('#app')
```

- **核心2步**
1. 创建需要的组件, 配置路由规则
	- 视图相关组件放到views目录中
	- 左侧地址栏路径, 右侧组件, 注意需要引包
```js
const router = new VueRouter({
	routes: [
		{path: '/find', component: Find},
		{path: '/my', component: My},
		{path: '/friend', component: Friend},
	],
})
```
2. 配置导航, 配置路由出口(路由匹配的组件显示的位置)
	- `router-view`标签会显示匹配页面的显示位置
	- a标签通过将href设置为`#/地址`来达到路由匹配
	- 或者使用router-link标签进行替代

#### 组件目录存放问题

- `.vue`文件并无本质区别, 只是为了便于区分, 更易维护
- 组件分类 - vue组件分两类
	- 页面组件
	- 复用组件

约定
- src/views文件夹 -> 页面组件 - 页面展示 - 配合路由用
- src/components文件夹 -> 复用组件 - 展示数据 - 常用于复用