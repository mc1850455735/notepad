## 生命周期

- 什么时候可以发送初始化渲染请求(越早越好)
- 什么时候可以开始操作dom(dom渲染完成后)

### 生命周期&生命周期四个阶段

- Vue生命周期: vue实例从**创建**到**销毁**的整个过程
- 生命周期的四个阶段: 创建, 挂载, 更新, 销毁
	- 创建阶段: 响应式数据处理
		- 发送初始化渲染请求等
	- 挂载阶段: 渲染模板
		- 操作DOM
	- 更新阶段: 修改数据, 更新视图
	- 销毁阶段: 销毁实例
- 创建, 挂载和销毁只执行一次, 更新阶段循环执行

### 生命周期钩子

Vue生命周期过程中, 会自动执行一些函数, 被称为生命周期函数
让开发者可以在特定阶段运行自己的代码
- beforeCreate
- <span style="color: red">created</span> => 发送初始化渲染请求
- beforeMount
- <span style="color: red">mounted</span> => 操作DOM
- beforeUpdate
	- 数据更新, 但DOM视图中的内容还没有更新
- updated
	- DOM视图中的内容更新完毕
- beforeDestroy => 释放Vue以外的资源(如延时器, 定时器等)
	- 专门的卸载Vue实例的语法
	- app.$destroy()
- destroyed
	- 卸载完成后并不会清理对应的Vue结构
	- 但是Vue的功能(如响应式变量)将不再能够使用

## 工程化开发入门

- 开发Vue的两种方式
	- 核心包传统开发方式 - 基于html/css/js文件, 直接引入核心包, 开发Vue
	- 工程化开发模式 - 基于构建工具(如webpack)的环境中开发Vue
		- 传统工程化开发的缺点: 
			- webpack配置不简单
			- 雷同的基础配置
			- 缺乏统一标准

### 工程化开发和脚手架

**工程化开发**
- 工程化构建过程
	- 源代码 -> 自动化 编译压缩组合 -> 运行的代码
	- es6语法 / typescript
	- less / sass
- 问题
	- webpack配置**复杂**
	- **雷同**的基础配置
	- 缺乏**统一标准**

**Vue CLI脚手架**
- 需求: 需要工具生成标准化配置
- Vue CLI是Vue官方提供的一个全局命令工具
	- 可以帮助我们快速创建一个开发Vue项目的标准化基础架子
	- 集成了Webpack配置
- 优点:
	- 开箱即用, 零配置
	- 内置babel等工具
	- 标准化
- 步骤
	1. 全局安装: `yarn global add @vue/cli` 或 `npm i @vue/cli -g`
	2. 查看vue版本: `vue --version`
	3. 创建项目架子: `vue create project-name` (项目名不能用中文)
	4. 启动项目: `yarn serve` 或 `npm run serve` (取决于项目配置)
- 注意
	- 项目名不能为中文
	- 项目名中不能含有大写字母
	- 项目至少由两个单词组成

**项目结构介绍**
- package.json
	- 内含着项目信息
	- 其中的scripts中存在着运行项目的命令名

### 项目运行流程
- 打开项目时尽量只打开当前项目的根目录, 防止相互之间的干扰

**项目结构**
- node_module -> 第三方包文件夹
- public -> 放html文件的地方
	- favicon.ico -> 网站图标
	- **index.html -> index.html模板文件**
		- index中的noscript用于给不支持js的浏览器进行提示
- src -> 源代码目录
	- assets -> 静态资源目录
	- components -> 组件目录, 存放通用组件
	- **App.vue -> App根组件, 项目运行看到的内容在此编写**
	- **main.js -> 入口文件, 打包或执行, 第一个执行的文件**
- .gitignore -> git忽略文件
- babel.config.js -> babel配置文件, 进行语法降级
- jsconfig.json -> js配置文件, 配置js语法提示
- package.json -> 项目配置文件, 内含项目名, 版本号, scripts, 依赖包等
- package-lock.json -> npm自动生成的锁定安装版本的锁文件
- README.md -> 项目说明文档
- vue.config.js -> vue-cli配置文件

**流程**
- index.html中的内容用于Vue注入模板
- 项目启动时, 最先执行main.js中的内容
	- 文件核心作用, 导入App.vue, 基于App.vue, 创建结构渲染index.html
	- App.vue 一般称之为根组件
- Vue.config.productionTip = false
	- 用于提示当前处于生产环境还是开发环境
	- true : 生产 ; false : 开发
- Vue实例化
	- 通过**render方法**, 基于App.vue创建结构, 渲染index.html
	- 完整写法: 
		- `render: 函数(createElement) { return createElement(App) }`
		- 基于app创建元素结构
	- `el: '#app'` 和 `.$mount('#app')` 效果相同
```js
new Vue({
  render: h => h(App),
}).$mount('#app')
```

**main.js核心代码**
- 导入Vue
- 导入App.vue
- 实例化Vue, 将App.vue渲染到index.html中

### 组件化

- 组件化: 一个页面可以拆成一个个组件, 每个组件有着自己独立的结构, 样式, 行为
	- 好处: **便于维护**, 利于复用 -> 提升**开发效率**
	- 组件分类: 普通组件, 根组件
- 根组件: 整个应用最上层的组件, 包裹所有普通小组件

**组件的三个组成部分**
- 结构: `<template>`
	- 有且只能有一个根元素(仅Vue2)
- 样式: `<style>`
	- 支持less, 需要装对应的less包
	- 方法:
		1. style中, lang='less', 开启less
		2. 装包: yarn add less less-loader / npm i less less-loader 
- 行为: `<script>`
	- 使用 `export default{ }` 导出当前组件的配置项
	- 内提供如 `data(特殊)`, `methods`, `computed`, `watch`, 生命周期钩子等配置项
```js
export default {
  methods: {
    handleClick() {
      console.log("click");
    },
  },
};
```

使用`<vue`快速生成vue模板

### 组件注册

- 使用时直接当作html标签使用`<组件名></组件名>`
- 使用大驼峰命名法
- 组件位置存储在src下的components文件夹中
- 在vscode -> 设置中搜索并勾选 trigger on tab, 即可打开tab转为标签的功能

##### 普通注册

- 局部注册
- 只能在注册的组件内使用
	- 创建.vue文件 => 单文件组件
	- 在使用的文件中导入并注册
- 导入
	- `import 组件名 from 组件位置`
	- `components: { '组件名': 组件对象 }`
	- 组件名和组件对象同名的, 可以忽略对应关系, 只写组件名
	- 导入后要求必须使用, 否则就会报错

##### 全局注册

- 全局注册
- 在所有的组件内都能使用
	- 创建.vue文件 => 单文件组件
- **main.js**中进行全局注册
	- 先通过import进行导入, 作为规范, 导入相关代码应该写到顶部
	- 脚手架环境中导入时, 加`.vue`文件名和不加, 不影响最终导入的结果
	- `Vue.component('组件名', 组件对象)`

**技巧**
- 一般都用局部注册, 如果发现确实是通用组件, 再抽离到全局

## 项目综合

- 每个组件最好都有其对应的前缀, 以增强可阅读性, 以及减少组件重名的可能性
- 折叠所有
	- ctrl + k, ctrl + 0
- 展开所有
	- ctrl + k, ctrl + j

#### 页面开发思路
1. 分析页面, 按模块拆分组件, 搭架子(局部或全局注册)
2. 根据设计图, 编写html和css代码
3. 拆分封装通用小组件

