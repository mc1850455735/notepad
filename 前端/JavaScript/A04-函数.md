- 实现代码复用

**函数**
function, 设置为**执行指定任务**的代码块
**说明**
将相同逻辑代码封装, 方便**代码复用**

### 函数使用

**声明**
```js
function 函数() {
	函数体
}
```

**命名规范**
- **小驼峰**命名法
- 前缀尽量是**动词**
- 常用动词
	- can : 是否可执行某个动作
	- has : 是否含有某个值
	- is : 是否为某个值
	- get : 获取某个值
	- set : 这是某个值
	- load : 加载某些数据

**函数调用**
- `函数名()`

### 函数参数

- 形参: 声明函数时小括号内的形参
- 实参: 调用参数中小括号内的实参
- 形参可以理解为函数中的**临时变量**
- 开发中尽量保证**形参和实参个数一致**
- 可以通过对象引用参数间接修改参数的值

**声明**
```js
function 函数名(参数列表) {
	函数体
}
```

**调用**
`函数(参数)`

**参数默认值**
- 如果不给形参赋值, **默认值为undefined**
- 可以手动给形参默认值, 方法为
	- 参数 = 默认值
- 只有在缺少参数时才会使用默认值
```js
function 函数名(参数1 = 1, 参数2 = 2) {
	函数体
}
```

### 函数返回值
- 调用函数后, 函数返回一个结果
- 有些函数有返回值, 有些没有

**语法**
- `return 数据`
- 想要返回多个值, 可以使用数组/对象装起来

**细节**
- 使用return传回函数内部处理的结果
- return后结束函数, 后面的**代码不会被执行**
- return不能换行, 值和return必须写在同一行
- 函数可以没有return, 此时**函数返回值为undefined**

**细节补充**
- 相同函数声明, 后一个会**覆盖**前一个
	- 严格模式会报错
- 实参和形参**个数可以不一致**
	- 实参多于形参, 多出部分被忽略
	- 形参多于实参, 多出部分定义为undefined
	- 函数内部有arguments, 存储所有的参数


### 作用域
- 变量可用的代码范围
- 提高程序逻辑局部性, 增强可靠性, 减少了名字冲突
- **如果没有声明直接赋值, 也是全局变量**
	- 不推荐这样使用

**全局作用域**
- **函数外部**的变量
- 各个script标签内部
- 整个js文件
**局部作用域**
- 作用于函数内的作用范围
- 函数内部形参也是局部变量

**访问原则**
- 只要是代码, 就至少有一个作用域
- 写在函数内部的为局部作用域
- 函数中嵌套函数, 则这个作用域中又会诞生一个作用域
- 访问变量时, **先局部, 再全局**

### 匿名函数

**具名函数**
```js
function fn(){}
fn()
```

**匿名函数**
- 无法直接使用
- **函数表达式** => 将函数**作为变量**存储
	- 具名函数可以在函数定义之前调用, 但是匿名函数必须在**使用之前进行定义**
- 立即执行函数
	- `(函数定义)(参数)` 
	- `(函数定义(参数))`
	- 避免全局变量之间的**污染**
	- 立即执行函数里面可以是**具名函数**, 也可以是**匿名函数**
	- 立即执行函数之间**必须加上分号**

```js
let fn = function() {}
fn()
```

### 逻辑中断
- 类似于默认参数的一种解决方案

```js
x = x || 0
y = y || 0
```


1. 逻辑与: 左边为false就短路
	1. 如果第一个不为真, 则取第一个的值
	2. 否则, 取第二个的值
2. 逻辑或: 左边为true就短路
	1. 如果第一个为真, 则取第一个的值
	2. 否则取第二个的值

**布尔型转换**
- 0, '' ,  undefined, null, NaN 转换为boolena都是false, 其余为true
**隐式转换**
- 字符串加法得字符串
- 减法只能用于数字, 会使空字符串转化为0
- null 数字换后为0
- undefined 数字换算后为NaN
