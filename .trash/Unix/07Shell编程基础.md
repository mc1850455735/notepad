
# 概述

**shell的类型**
- sh
- csh/tcsh
- bash
- ksh
- zsh

**shell功能**
- 命令解释器
- 文件名替换, 命令替换, 变量替换
- 历史替换, 别名替换
- 流程控制的内部命令

**历史替换**
- 历史表: $HOME/.bash_history
- 引用历史记录
- 上下箭头
- !!引用上一命令
- !str : str开头最近用过的命令

**别名**
- 查看别名: alias
- 设置别名: alias mm='mv -i'
- 取消别名: unalias n

**用处**
- 交互方式下 : 熟悉shell的替换机制, 转义机制, 循环等流程控制
- 非交互方式下: 编写shell脚本程序

# Shell变量

### 变量使用

**命名**
- 首个字符不能以数字开头
- 其余字符可以是字母, 数字, 下划线
- 中间不能有空格
- 不能使用标点
- 不能使用bash关键字

**赋值**
格式 : NAME=value
**引用**
格式 : $NAME 或 ${NAME}
**删除**
- unset NAME
- 被删除后不能再次使用, 不能删除只读变量

**输入命令**
从标准输入读入一行内容赋值给变量
**格式**: read name
**参数** : -p -> 设置提示信息

**输出命令**
- echo
	- 格式: echo arg1 arg2 ...
- printf
	- 格式 : `printf format-string [arguments]`
	- 格式字符
	- %s -> 输出字符串
	- %d -> 整型输出
	- %c -> 输出一个字符
	- %f -> 输出实数, 以小数形式

**字符串**
字符串常见操作
- `${#var}` : 返回字符串长度
- `${var:m}` : 返回从第m个字符之后的所有字符
- `${var:m:len}` : 返回从第m个字符之后长度为len的子串
- `${var#pattern}` : 删除开头部分与pattern匹配的子串
- `${var%pattern}` : 删除结尾部分与pattern匹配的子串
- `${var/old/new}` : 用new替换字符串中第一次出现的old子串
- `${var//old/new}` : 用new替换字符串中所有的old子串
- `${var/#old/new}` : 用new替换字符串开头与old匹配的子串
- `${var%old/new}` : 用new替换字符串结尾与old匹配的子串

### 变量类型

##### 本地变量 
在脚本或命令中定义, 仅在**当前shell中有效**

##### 环境变量
使用env命令查看所有环境变量

**定义**
- NAME=value(定义)
- export NAME (导出)
- echo $NAME (使用)
- unset NAME (清除)

**常见环境变量**
- PATH : 帮助shell找到用户输入的命令
- PWD和OLDPWD : 记录**当前**工作目录和**旧有的**工作目录
- HOME : 记录当前用户根目录
- SHELL : 保存shell的值, 默认shell值 /bin/bash
- USER和UID : 保存已登录用户的名字和ID
- PS1和PS2 : 提示符变量, 用于设置提示符格式

**环境变量配置文件**

**加载顺序**

**登录式用户**
![[课程/Unix/Inbox/Pasted image 20240429082212.png]]
**非登录式用户**
![[课程/Unix/Inbox/Pasted image 20240429082315.png]]

**配置文件作用**
系统级 : 对所有用户生效
- `/etc/profile`
	- USER变量
	- LOGNAME变量
	- MAIL变量
	- PATH变量
	- HOSTNAME变量
	- HISTSIZE变量
	- umask
	- 遍历调用`/etc/profile.d/*.sh`文件
- `/etc/profile.d`
- `/etc/bashrc`
	- PS1变量
	- PATH变量(非登录用户)
	- umask (非登录用户)
	- 遍历调用`/etc/profile.d/*.sh`文件 (非登录用户)
用户级 : 对当前用户有效
- `~/.bash_profile`
	- 调用`~/.bashrc`文件
	- PATH变量后加入 `$HOME/bin` 目录
- `~/.bashrc`
	- 定义别名
	- 调用`/etc/bashrc`文件

**配置文件重新生效**
1. 注销后重新登录
2. 使用**source命令**
	- `source /etc/profile`
	- `. /etc/profile`

#### 位置变量
- 用来向Shell脚本传递参数
- 以单个正数来命名 `$n`
- `$n`代表第n个位置参数
	- 注意: $符号不能少
- 例: `$1` , `${10}`

#### 特殊变量
- `$#` : 传递到脚本的**参数个数**
- `$*` , `$@` : 传递到脚本的**所有参数**
- `$?` : 命令退出状态 -> 0无错误, 非0有错误
- `$$` : 本程序进程的**PID**
- `$!` : 上一个后台进程的**PID**


## 特殊字符

#### 引号
- 单引号 : 可以屏蔽Shell中元字符的功能
- 双引号, 屏蔽, 但是不会屏蔽 ``$, \, `反引号` `` 符号
- 反引号: 命令替换, 使用命令输出替换反引号内容, 可与双引号配合使用

#### 通配符
- `*` : 匹配0个或多个字符
- `?` : 匹配任意一个字符
- `[]` : 与`[]`中的任一字符相匹配
- `[!]` : 与 `[]`之外的任一字符匹配

#### 连接符

**; 连接符**
命令按照先后顺序依次执行
**&& 连接符**
执行准寻逻辑与关系, 前面的执行成功, 后面的才执行
**|| 连接符**
前面的执行失败, 后面的才执行

**其他字符**
- `;;`     ->  case终止符
- `:`       -> 空命令, 相当于true
- `.`       -> 相当于source命令
- `#`       -> 注释

# Shell脚本

## 基本元素

`#!` 开头, 指定命令解释器
1. Shell解释器运行脚本
	- `bash test.sh`
	- 将脚本文件作为参数传递给解释器, 只需要有脚本文件读取权限即可
	- 可以使用-x参数调试
2. 通过source运行脚本
	- `source test.sh`
	- `. test.sh`
	- source是shell内部命令, 功能是读取执行的Shell文件并依次执行
3. 直接运行脚本
	- 赋予脚本**执行权限**, 然后直接运行
	- `chmod 777 test.sh`
	- 要求必须有执行权限

# 流程控制

### 运算符

**算数运算符**
- 算数运算符 : `+ - * / %`
- 算数表达式求值 : `$[表达式]` 或 `$((表达式))`

**expr指令**
- 求表达式变量的值, 一般用于整数值, 也可以用于字符串
- 空格隔开每个选项, 反斜杠 `\` 放在shell特定前(如可以作为通配符的`*`)

**let指令**
用于执行一个或多个表达式, 变量不需要加上$

### 条件测试语句

##### 条件测试

**test**
格式 `test <测试表达式>`
例 : `test -f file && echo true || echo false`

**`[ ] 或者 [[ ]]`**
**格式** `[ <测试表达式> ]`
例 : `[ -f file ] && echo true || echo false`
`[[ ]]`支持**通配符和正则表达式**

**条件测试操作符**
- -b : 检查文件是否是块设备文件
- -c : 检查文件是否是字符设备文件
- -d : 检查文件是否是目录
- -f : 检查文件是否是普通文件
- -L : 检查文件是否是链接文件
- -p : 检查文件是否是有名管道
- -r : 检查文件是否可读
- -w : 检查文件是否可写
- -x : 检查文件是否可执行
- -s : 检查文件**是否为空**
- -e : 检查文件**是否存在**

##### 整数测试
用于整数之间运算
格式 : `[整数1 操作符 整数2]`
例 : `$i -eq 0`

**整数测试操作符**
- -eq : 等于
- -ne : 不等于
- -gt : 大于
- -lt : 小于
- -le : 小于等于
- -ge : 大于等于

**也可以使用C语言中的关系运算符**
使用C语言符号时, 要用双小括号 `(())`

##### 字符串测试
作用 : 比较字符串是否相等, 长度是否为0
**格式** : `[ 字符串1 = 字符串2 ] [ -z 字符串 ]`

**选项**
- -z : 判断字符串长度是否为空
- -n : 判断字符串长度是否不为空
- != : 判断两字符串不等
- = / == : 判断两字符串相等

##### 逻辑运算符
格式 `[ 表达式1 操作符 表达式2 ]`
例 : `[ $x -eq 1 -a -n $name ]`

**选项**
- -a 或 && -> 两边为真则为真
- -o 或 || -> 一边为真即为真
- ! : 两边均假即为真

### 判断结构

- if结构必须以if开头, fi结尾
- elif 可以有任意个
- else 最多一个
- 命令语句如果为空, 使用冒号(:)返回退出状态0
- expression如果为命令, 以最后一个命令退出状态为条件值

#### if结构
```shell
if expression
then
	命令语句
fi
if expression; then
	命令语句
fi
```

#### if-else结构
```shell
if expression; then
	命令语句1
else
	命令语句2
fi
```

#### if-elif-else结构
```shell
if expression1; then
	命令语句1
elif expression2; then
	命令语句2
...
else 
	命令语句n
fi
```

#### case结构
```shell
case "$var" in
var1)
	命令语句1;;
...
*) 
	命令语句n;;
esac
```

**总结**
- 按顺序匹配, 匹配成功**执行该分支所有命令**
- 没有匹配的模式, 执行**默认值`*)`**后的命令
- 每个分支必须以**双分号结尾**

### 循环结构




# 函数

#### 函数语法
语法格式
```shell
[function] 函数名[()]{
	commands;
	[return int;]
}
```

#### 函数调用
语法格式
`函数名`
`函数名 参数1 参数2 ...`

**函数存储**
- 函数和调用程序保存在同一个文件
	- 函数定义在前, 调用在后
- 函数和调用程序保存在不同文件
	- 函数文件先source命令执行

#### 函数参数
- 通过`$n`形式获取参数值
- $0表示**脚本名**
- 调用结束后, `$n`, `$*`被重置为调用函数之前的值

#### 函数返回值
函数返回值为最后一条命令的退出码, 保存在$?中, return的返回值只能返回0-255的整数

# 正则表达式

#### 概念
- 正则表达式是**对文本进行过滤**(分割,匹配,查找,替换)的工具
- 他定义了一系列的元字符, 通过元字符配合以他字符表达出**一种规则**, 只有符合规则的文本的文本才能保留下来
**与通配符区别**
- 通配符 : 匹配文件名, 完全匹配, ls, find, cp命令
- 正则表达式 : 匹配字符串, 包含匹配, grep, awk,sed命令

#### 元字符

**基础元字符**
- 限定符`*` : 匹配**前面一个普通字符**0次或多次重复
	- `a*` : 任意字符串包括空白字符
- 单个字符匹配符号`.` : 匹配**任意单个字符**(除`\n`)
- 行首定位符 `^` : 匹配**行首**字符
	- `^a` : 行首为a
- 行尾定义符 `$` : 与 `^` 正好相反
	- `a$` : 行尾为a
	- `^$` : 匹配空白行
- 字符集匹配符号`[]` : 指定一个**匹配**的**字符集集合**
- 字符集不匹配符号`[^]` : **不匹配**字符集的任意字符
- 转义符 `\` : **屏蔽**一个元字符的特殊意义
- `{n}` : 匹配前面字符**出现n次**
- `{n,}` : 匹配前面字符**至少出现n次**
- `{n,m}` : 匹配前面字符**n到m之间**

**扩展元字符**
- `+` : 匹配前面的字符1次或多次
- `?` : 匹配前面的字符0次或1次
- `|` : 多个正则表达式的**或**关系
- `()` : 表示一组可选的集合, 通常配合`()`

![[课程/Unix/Inbox/Pasted image 20240429102126.png]]

**常用字符簇**
- `^[1-9][0-9]{0,}$`  ->  正整数
- `^\-{0,1}[0-9]{1,}$`  -> 数字(包括正数)
- `[0-9]{4}-[0-9]{2}-[0-9]{2}`
- `[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}`
在线测试: http://regex101.com/

# 命令

#### grep命令
见 : [[课程/Unix/01文件系统]]

#### cut命令
- 显示每行从开头算起num1到num2的文字
- 语法
- `cut [-bn] [file]`
- `cut [-c] [file]`
- `cut [-df] [file]`

**参数**
- -b : 以字节为单位进行分割
- -c : 以字符为单位分隔
- -d : **自定义分隔符**, 默认为制表符
- -f : 与-d一起使用, 指定显示哪个区域
- -n : 取消分隔多字节字符, 与-b一起使用

#### awk命令
- 一种强大的数据处理工具, 本身是一种程序设计语言
- **字符串行处理工具**, 用于统计, 制表

**两部分组成**
- 模式匹配
	- 如果没有指定匹配模式, 默认匹配所有数据
- 处理数据
	- 匹配, 则处理数据
	- 否则不做任何处理
	- 没有指定处理方式则输出
![[课程/Unix/Inbox/Pasted image 20240429104345.png]]

**语法格式**
``awk [选项] `BEGINP{action} pattern{actions} END{actions}` 文件 ``

执行流程
1. 执行BEGIN{actions}语句块中的语句
2. 从文件或标准输入(stdin)读取一行, 然后执行pattern{actions}语句块, 逐行扫描文件, 从第一行到最后一行
	- pattern : 条件, 一般使用关系表达式作为条件
	- actions : 动作
		- 格式化输出语句
		- 流程控制语句
3. 读至输入流末尾, 执行END{actions}语句

**选项**
- -F : 执行**作为输入行的分隔符**, 默认为tab
- -v : 赋值一个用户定义的变量
- -f : 从脚本文件读取awk指令

##### 语法格式

**关系表达式**
- > , < , <= , >= , == , !=
- ~ : 匹配正则表达式
- ! : 不匹配正则表达式
**逻辑运算符**
- ! , &&, ||
**正则模式匹配**
- /pattern/ : 全行数据正则匹配
- !/pattern/ : 全行数据正则匹配取反
- ~/pattern/ : 特定数据正则匹配
- !~/pattern/ : 特定数据正则匹配取反
**区间模式**
- pattern1, pattern2
- 从匹配pattern1的文本行开始, 到匹配pattern2的文本行结束

**使用方式**
- ``awk `pattern` filename ``
- ``awk `{action}` filename ``
- ``awk `pattern{action}` filename ``

##### 常用变量
- $0 : 当前行的全部字段
- $n : 当前行的第n个字段
- NR : 行号
- NF : 当前行的字段个数
- $NF : 最后一个字段值
- FILENAME : 当前文件名

##### 流程控制
- if
- while
- for

#### sed
Linux中用于文本处理的一款工具
一次读取一行内容进行处理, 通过文件或管道将内容读取到模式空间进行处理, 然后输出
![[课程/Unix/Inbox/Pasted image 20240429110550.png]]

##### 语法格式
格式 : `sed [选项] 'sed编辑命令' 输入文件`
**选项**
- -n : 关闭默认的模式空间输出
- -e : 将下一个字符串解析成为命令
- -f : 编辑脚本内容, 表明正在使用脚本
- -r : 在脚本指令中使用拓展正则表达式
- -i : 直接修改源文件(慎用)

**常用编辑命令**
- p : 打印匹配行
- = : 显示文件行号
- `a\` : 定位行号之后追加文本信息
- `i\` : 定位行号之前插入文本信息
- d : 删除定位行
- `c\` : 新文本替换定位文本
- s : 使用替换模式替换相应模式
- r : 从一个文件中都文本
- w : 文本写入到一个文件
- {} : 定位行执行命令组

##### 行定位
- 指定行号
	- `sed -n '1p' /etc/passwd`
- 指定正则匹配
	- `sed -n '/root/p' /etc/passwd`
- 指定起始行
	- `sed -n '1,3p' /etc/passwd
- 指定间隔行
	- `sed -n '1~3p' /etc/passwd`
- 指定最后一行
	- `sed -n '$p' /etc/passwd`

##### sed操作
**打印**
- p命令
- =命令
- -n选项
















