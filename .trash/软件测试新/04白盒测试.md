- 又称**结构测试**或**逻辑驱动测试**

**概念**
- 把测试对象看做一个透明的盒子
- 允许测试人员利用程序内部的逻辑结构及有关信息 设计或选择测试用例
- 在不同点检查程序的状态，确定实际 的状态是否与预期的状态一致

**程序结构**
- 流程图
- N-S图
- 控制流图
- 数据流图

# 语句级覆盖

### 面向单语句

##### 语句覆盖
- 选取足够多的测试数据，使被测试程序中**每个语句**至少执行一次
- 是**很不充分**的一种标准，是最弱的逻辑覆盖准则

##### 判定覆盖
- 也称为分支覆盖(Branch Coverage/Decision Coverage)
- 选取足够多的测试数据，确保每个分支**可能的出口**都被执行一次
- 说明: 含有判定的语句, 除了双值的以外, 还可能有多值, 如switch
- “判定覆盖”比“语句覆盖”严格, 因为如果每个判定都执行过了，则每个语句也就执行过了
- 但还是不够充分, 还是有可能遗漏相应的路径

##### 条件覆盖
- 选取**足够多**的测试数据，要求代码中**每个布尔表达式中的每个条件**都要在测试中取到 `true` 和 `false` 两种值
- “条件覆盖”通常比“判定覆盖”强, 因为它使一个判定中的每一个条件都取到了两个不同的结果
- “条件覆盖”并**不包含“判定覆盖”**

##### 判定/条件覆盖
- 选取**足够多**的测试数据，使得判定表达式中的每个**条件**都取到各种可能的结果，而且每个**判定表达式**也都取到**各种可能的结果** 
- 从表面来看，它测试了**所有条件的取值**. 但是可能存在一些条件掩盖了另一些条件(**与或操作**)

##### MC/DC覆盖
- MC/DC (Modified Condition/Decision Coverage)
- Executing the independent true and false outcomes of each condition
- 独立的执行每个表达式中的true或false

##### 条件组合覆盖
- 选取足够多的测试数据，使得判定表达式中条 件的**各种可能组合**都至少出现一次

**联系**
![[课程/软件测试新/Inbox/Pasted image 20240613011503.png]]

# 路径级覆盖

### 路径覆盖
- 选取足够多的测试数据，使得程序的**每条可能路径**都至少执行一次

**难点**
- 判定问题, 循环问题
**处理方法**
- 实际循环次数处理
- 选择循环次数处理
- 考虑图结构特征的处理

### 实际循环次数分析
- 结构分析
- 实际循环次数
- 符号执行

**实际循环次数处理**
- 结构分析
- 实际循环次数
- 符号执行

### 选择循环次数测试

**简单循环测试方法**(假设有n次循环)
- 跳过循环
- 一次通过循环
- 两次通过循环
- m次通过循环(m<n)
- n-1, n, n+1次通过循环

### 基于图结构的路径测试

**图结构**
图 G=（V，E），节点与边，可能存在环路
**结构处理策略**
- Mccab圈复杂度
- 一个图的基本路径集合数目是确定，图中的任意路径都可以表示为基本路径的线性组合

**控制流图**
![[课程/软件测试新/Inbox/Pasted image 20240613092325.png]]

**判断语句分解为条件**
- 如果判断中的条件是由一个或多个逻辑运算符连接的复合条件表达式
- 那么需要改为一系列**单条件嵌套判断**

**顺序语句合并为单节**
![[课程/软件测试新/Inbox/Pasted image 20240613092946.png]]

### 基本路径测试

##### 基本路径计算
- **区域** : 由边和解点封闭起来的区域
- **基本路径** : 至少沿一条**新的边**移动的路径
	- 遍历完所有基本**路径**, 就可以至少一次的执行了程序中的所有语句

##### 计算圈复杂度
三种方法
- 流图中区域的数量对应于环型的复杂性
- 流图G的圈复杂度V(G)，定义为V(G)=E-N+2，E是流图中边的数量，N是流图中结点的数量
- 流图G圈复杂度V(G)，定义为 V(G)=P+1，P是流图G中**判定结点**的数量(也叫**谓词节点**)

**计算原则**
- 每条基本路径需**要包含一条新边**
- 每条基本路径不能新出现同一个判定节点的TRUE和False
- 每条基本路径的尽可能少的改变原基本路径的判定方向

**测试用例举例**
![[课程/软件测试新/Inbox/Pasted image 20240613094048.png]]

# 切片技术

**思想**
- 对原程序进行裁剪, 使得到的程序代码仍能反应原程序的部分特征
- 程序切片按照切片原则裁剪程序, 使人注意力集中在相关程序代码中
**定义**
给定一个**程序P**和P中的一个**变量集合V**，变量集合 V在语句n上的一个片，记作S(V,n)，是P中对V中的变量值作出贡献的所有语句集合

**控制依赖**
- 设C是包含结点n1和n2的**控制流图**, 如果下面两个条件同时成立，则称结点n2控制依赖于n1
	- 至少存在一条从n1到程序出口的路径，该路径包含n2
	- 至少存在一条从n1到程序出口的路径，该路径不包含n2
**数据依赖**
- 设D是包含结点n1和n2的数据依赖图, 下面两个条件同时成立，则称结点n2数据依赖于n1
	- 变量v在n1处定义、在n2处引用
	- 存在一条从n1到n2的**非空路径**，**不包含任何重定义v**的结点

**依据程序依赖图计算静态切片**
- 在程序依赖图中求出**所关心结点**的**逆向传递闭包**就可以得出它所数据依赖、控制依赖的结点
	- 就是把会用到的程序段取出作为组成的程序段
- 由以上计算所得结点对应的程序语句**所组成的程序段**即为所求**静态切片**

**作用**
- 程序调试
- 软件测试
- 软件维护
- 软件复用

# 变异技术

**基本概念**
- **变异算子** : 在符合语法规则前提下，**变异算子**定 义了从原有程序生成差别极小程序（即**变异体**）的转换规则
- **一阶变异体**: 在原有程序p上执行**单一变异算子** 并形成变异体p′ ,则称p′为p的一阶变异体
- **高阶变异体**: 在原有程序p上依次执行**多次变异 算子**并形成变异体p′ ,则称p′为 p 的高阶变异体
	- 执行k次变异算子,称p′为 p 的 k 阶变异体
- **可杀变异体**: 若存在测试用例 t, 在变异体 p′ 和原有程序 p 上的**执行结果不一致**, 则称p'相对于测试用例集T是可杀变异体
- **可存活变异体**：若**不存在任何测试用例t** ， 在 变异体 p′ 和原有程序 p 上的执行结果不一致
- **等价变异体**：若变异体 p′ 与原有程序 p 在**语法上存在差异, 但在语义上保持一致**， 则称p′ 是 p 的等价变异体
	- 如
![[课程/软件测试新/Inbox/Pasted image 20240613102440.png]]

**变异测试流程**
![[课程/软件测试新/Inbox/Pasted image 20240613102507.png]]

**种类**
略

# 总结

- “白盒”法全面**了解程序内部逻辑结构**、对所有逻辑路径进行测试。
- “白盒”法是**穷举路径测试**。在使用这一方案时，测试者必须检查程序的内部结构，从检查程序的逻辑着手，得出测试数据。
- 贯穿程序的**独立路径数是天文数字**。但即使每条路径都测试了**仍然可能有错误**。
	1. 穷举路径测试决**不能查出程序违反了设计规范**， 即程序本身是个错误的程序；
	2. 穷举路径测试**不可能查出程序中因遗漏路径而出错**。
	3. 穷举路径测试可能**发现不了一些与数据相关的错误**。
