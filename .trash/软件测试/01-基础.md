
# PIE模型

- Fault => 不论执不执行都存在
	- 静态存在于软件中的错误
- Error => 执行中遇到了Fault产生
	- 运行中错误的中间状态
- Failure => 由于Error导致的错误的结果被观察到
	- 被用户观察到的运行时的错误

**对应关系**
- Execution -> Fault
- Infection -> Error
- Propagation -> Failure

**观测Failure的三个条件**
- 执行(Execution) -> 必须通过错误的代码
	- 测试未必能执行到Fault的位置, 使Fault隐藏在代码中
- 感染(Infection) -> 错误的代码必须导致错误的中间状态
	- 执行到错误的代码不一定有错误的产生
- 传播(Propagation) -> 错误的中间状态必须传播到最终输出
	- 错误的产生不一定有错误的输出
	- 后续操作可能掩盖了Error导致Failure不出现

**疑问**
- 存不存在Fault不能被任何测试发现?
- 这种Fault真的是Fault吗?

# 测试术语

**测试用例**
- 测试输入(测试用例输入什么值)
- 测试预言(预期的输出)
- 其他(测试环境等)

**测试和调试**
- 测试: 发现bug
	- 执行软件观察是否失效
- 调试: 修正bug
	- 找到fault, 理解fault, 修正fault

**Verification & Validation**
- Validation
	- 确认文档是否是用户所需要的
- Verification
	- 确认文档和实现是否一致

**静态测试 & 动态测试**
- 区别 : 是否需要运行程序
- 静态测试主要靠观察代码

**黑盒测试 & 白盒测试**
- 黑盒 : 不需要源代码
- 白盒 : 需要源代码
- 灰盒测试 : 通过其他软件或反编译等手段获得部分代码片段并进行测试

**测试层次**
- 单元测试
- 模块测试
- 集成测试
- 系统测试

**测试过程**
- 略

# Fault反思

**Fault可以通过测试或者修复来定义**
- 不同的定义方法Fault数量可能不同
- 相同定义方法的不同途径也有可能发现Fault的数量不同

- 如何确定看见的缺陷代码就是Fault (hard)
	- 不同的修复方式修改的代码不同
	- 同一个Fault测试用例不同就不一定能发现
	- 不同的修改位置可能导致修改的数量不同
	- Fault之间还存在互相干扰的情况
	- 所以fault的真正定义非常模糊, 没有明确定义
- 如何断定某状态是错误的中间状态 (hard)
- 判断最终结果是否出错 (easy)
 




















