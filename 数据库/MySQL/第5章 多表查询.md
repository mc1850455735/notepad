
# 多表关系

- 项目研发中, 在进行数据库表结构设计时,  会根据业务需求以及业务模块之间的关系分析并设计表结构,  由于业务之间相互关联,  所以各个表结构之间也存在着**各种联系** : 一对多, 多对一, 多对多, 一对一

**一对多(多对一)**
- 实现 - 在多的一方建立外键,  指向单独一方的主键
- 如 : 员工表 和 部门表 之间的对应关系
```sql
ALTER TABLE emp ADD CONSTRAINT fk_emp_dept_id FOREIGN KEY (dept_id) REFERENCES dept(id);
```

**多对多**
- 实现 - 建立一张中间表 , 中间表中**至少包含两个外键**,  分别关联两方主键
```sql
CREATE TABLE student_course(
	id INT PRIMARY KEY auto_increment COMMENT '主键',
	studentid INT NOT NULL COMMENT '学生ID',
	courseid INT NOT NULL COMMENT '课程ID',
	CONSTRAINT fk_courseid FOREIGN KEY (courseid) REFERENCES course(id),
	CONSTRAINT fk_studentid FOREIGN KEY (studentid) REFERENCES student(id)
) COMMENT '学生课程中间表';
```

**一对一**
- 实现 - 在**任意一方**加入外键关联另外一方的主键,  并设置外键为**unique**
- 通常用于单表拆分, 将基础字段放在一张表中, 其他详细信息放在另一张表中, 提高操作效率
```sql
create table tb_user(  
    id int auto_increment primary key comment '主键ID',  
    ... 
) comment '用户基本信息表';  
  
create table tb_user_edu(  
    id int auto_increment primary key comment '主键ID',  
    ...
    userid int unique comment '用户id',  
    constraint fk_userid foreign key (userid) references tb_user(id)  
);
```

# 多表查询

### 基础

- 从多张表中进行数据查询
	- 笛卡尔积 - 是指在数学中 , 两个集合A和B的所有组合情况 (在多表查询时 , 需要消除无效的笛卡尔积)
	- 使用where条件, 消除两张不同表组合时的无意义数据, 只保留子表外键与父表主键相同的条目
- 实际上, 不需要加入外键约束也可以使用这种方式进行组合查询, 但是外键约束是一种对操作行为的约束, 并且可以起到提醒属性作用的目的
```sql
select *
from emp, dept
where emp.dept_id = dept.id;
```

### 分类

**多表查询分类**

- 连接查询
	- 内连接 - 相当于查询A, B的**交集部分**数据
	- 外连接
		- 左外连接 - 查询**左表**所有数据, 以及两张表交集部分数据
		- 右外连接 - 查询**右表**所有数据, 以及两张表交集部分数据
	- 自连接 - 当前表与自身的连接查询, 自连接**必须使用表别名**
- 子查询
![[数据库/MySQL/Inbox/Pasted image 20250818172151.png]]

# 连接查询

### 内连接

- 内连接查询的是两张表**交集**的部分
- 查询时, 如果表名较长, 可以为表名起别名, 起完别名后, 原表名在查询语句中就无法被使用
- **隐式内连接**
	- `SELECT 字段列表 FROM 表1, 表2 WHERE 条件;`
- 示例: 查询每一个员工的姓名, 以及关联部门的名称(隐式内连接)
```sql
select emp.name, dept.name from emp, dept 
where emp.dept_id = dept.id;
```

- **显式内连接**
	- `SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 连接条件;`
- 示例: 查询每一个员工的姓名, 以及关联部门的名称(显式内连接)
```sql
select emp.name, dept.name from emp 
inner join dept on dept.id = emp.dept_id;
```


### 外连接

**注意**
- 无论左还是右, 都会返回对应方向表的所有数据, 无论这个方向有没有匹配上, 同时将另个方向表的匹配数据也返回
- 对于存在没有对应条目的表, 没匹配上的部分会显示为 null

- 左外连接 : 左表和左右表交集的部分
	- `SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件;`
	- 通常情况下, 左外连接在实际开发中更多见, 因为右外可以被改造为左外
- 示例: 查询员工表所有数据, 以及对应的部门信息(左外连接)
```sql
select e.*, d.name from emp e left join dept d on e.dept_id = d.id;
```

- 右外连接 : 右表和左右表交集的部分
	- `SELECT 字段列表 FROM 表1 REIGHT [OUTER] JOIN 表2 ON 条件;`
- 示例: 查询部门表所有数据, 以及对应的员工信息(右外连接)
```sql
select d.*, e.name from emp e right join dept d on d.id = e.dept_id;
```


### 自连接

- 自连接查询可以是内连接, 也可以是外连接
- 自连接查询中, 表必须起别名, 否则无法区分
```sql
SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件;
```

- 示例01 : 查询员工及其所属领导的名字
```sql
select e1.name, e2.name from emp e1, emp e2 
where e1.managerid = e2.id;
```

- 示例02 : 查询所有员工及其领导的名字, 如果员工没有领导, 也需要查询出来
```sql
select e1.name, e2.name from emp e1 
left join emp e2 on e1.managerid = e2.id;
```

**联合查询**
- 联合查询分为 union 和 union all
- 联合查询, 必须保证多张表的**列数**和**字段类型**保持一致
- union查询就是把多次查询的结果**直接合并**起来形成一个新的查询结果集
- union all 将全部数据都直接合并, union会在合并后去重
```sql
SELECT 字段列表 FROM 表A
UNION [ALL]
SELECT 字段列表 FROM 表B ...;
```

- 示例01 : 将薪资低于5000和年龄大于50的员工全部查询出来
```sql
select * from emp where salary < 5000  
union  
select * from emp where age > 50;
```

# 子查询

**概念**
- sql中的嵌套select语句,  又称为嵌套查询,  又称**子查询**
- 外部的语句可以是 `INSERT` / `UPDATE` / `DELETE` / `SELECT` 的任意一个
```sql
SELECT * FROM t1 WHERE column1 = (SELECT column1 FROM t2);
```

**根据子查询结果不同**
- 标量子查询 - 子查询结果为**单个值**
- 列子查询 - 子查询结果为一列
- 行子查询 - 子查询结果为一行
- 表子查询 - 子查询结果为多行多列

**根据子查询位置**
- `WHERE` 之后
- `FROM` 之后
- `SELECT` 之后

### 标量子查询

- 子查询返回的结果是单个值(数字, 字符串, 日期 等) , 最简单的形式 , 这种子查询称为**标量子查询**
- 常用的操作符 : `=` , `<>` , `>` , `<` , `>=` , `<=`

**示例**
- 示例01 : 查询 '销售部' 所有员工信息
```sql
select emp.* from emp where emp.dept_id = (  
select dept.id from dept where dept.name = '销售部')
```
- 示例02 : 查询在方东白之后入职的员工信息
- 查询日期先后, 直接使用 比较符号 即可获得先后顺序
```sql
select emp.* from emp where entrydate > (select entrydate from emp where name = '方东白');
```

### 列子查询

- 子查询返回的结果是一列(可以是多行) , 这种子查询称为列子查询
- 常用操作符 : `IN, NOT IN, ANY, SOME, ALL`

![[Pasted image 20221219140252.png]]

**案例演示**
- 案例01 : 查询 '销售部' 和 '市场部' 的所有员工信息(使用in)
```sql
select * from emp where emp.dept_id in 
(select id from dept where dept.name in ('销售部', '市场部'));
```
- 案例02 : 查询比财务部所有人工资都高的员工信息(使用all)
```sql
select * from emp  
where emp.salary > all (select salary from emp  
where emp.dept_id = (select id from dept  
where name = '财务部'));
-- 或 --
select * from emp  
where emp.salary > (select max(salary) from emp 
where emp.dept_id = (select id from dept 
where name = '财务部'));
```
- 案例03 : 查询比研发部其中任意一人工资高的员工信息(使用any/some)
```sql
select * from emp where salary > any
(select salary from emp where dept_id = 
(select id from dept where dept.name = '研发部'));
```


### 行子查询

- 子查询返回的结果是一行 (可以是多列) , 这种子查询称为**行子查询**
- 常用操作符 :  `=` , `<>` , `IN` , `NOT IN`

**示例**
- 示例01 : 查询与张无忌的薪资以及直属领导相同的员工信息
- 使用 (salary, managerid) = (12500, 1) 可以快捷查询salary和managerid是否等于12500和1
```sql
select * from emp where (salary, managerid) = (select salary, managerid from emp where name = '张无忌');
```

### 表子查询

- 子查询返回的结果是多行多列 , 这种子查询称为**表子查询**
- 常用操作符 - IN

**示例**
- 示例01 : 查询与鹿杖客, 宋远桥职位和薪资相同的员工信息
- 表子查询使用in来查询, 相当于对子表内容挨个进行行子查询
```sql
select * from emp where (emp.job, emp.salary) in (select job, salary from emp where name in ('鹿杖客', '宋远桥'));
```
- 示例02 : 查询入职日期在'2006-01-01'之后的员工信息, 以及其部门信息
- 使用表子查询, 以表子查询查出的表作为新的表, 对其进行左外连接查询
```sql
select * from 
(select * from emp where entrydate > '2006-01-01') as e 
left join dept d on e.dept_id = d.id;
```

#  查询综合案例

**案例01** : 查询员工的姓名、年龄、职位、部门信息（隐式内连接）
```sql
select e.name, e.age, e.job, d.name 
from emp e, dept d where e.dept_id = d.id;
```
**案例02** : 查询年龄小于30岁的员工的姓名, 年龄, 职位, 部门信息(显式内连接)
```sql
select e.name, e.age, e.job, d.name 
from emp e join dept d on d.id = e.dept_id where age < 30;
```
**案例03** : 查询拥有员工的部门ID、部门名称 - 使用distinct去重
```sql
select distinct d.id, d.name 
from dept d join emp e on d.id = e.dept_id;
```
**案例04** : 查询所有年龄大于40岁的员工, 及其归属的部门名称; 如果员工没有分配部门, 也需要展示出来
```sql
select e.*, d.name from emp e 
left join dept d on d.id = e.dept_id where age > 40;
```
**案例05** : 查询所有员工的工资等级
- 使用隐式内连接与最大最小值进行查询
```sql
select emp.*, salgrade.grade from emp, salgrade 
where emp.salary between salgrade.losal and salgrade.hisal;
```
**案例06** : 查询 "研发部" 所有员工的信息及工资等级
```sql
select e.*, s.grade from emp e, salgrade s 
where e.salary between s.losal and s.hisal 
and e.dept_id = (select id from dept d where d.name = '研发部')
```
**案例07** : 查询 "研发部" 员工的平均工资
```sql
select avg(emp.salary) from emp, dept 
where emp.dept_id = dept.id and dept.name = '研发部';
```
**案例08** : 查询工资比 "灭绝" 高的员工信息。
```sql
select *  
from emp e  
where e.salary > (select salary from emp e2 where e2.name = '灭绝');
```
**案例09** : 查询比平均薪资高的员工信息
```sql
select * from emp where salary > (select avg(salary) from emp);
```
**案例10** : 查询低于本部门平均工资的员工信息 (分组聚合/表外字段查询)
```sql
select *  
from emp e,  
     (select emp.dept_id id, avg(salary) sal from emp group by emp.dept_id) avg_sal  
where e.dept_id = avg_sal.id  
  and e.salary > avg_sal.sal;
-- 或 --
select * from emp e1  
where e1.salary < (select avg(salary) from emp e2 where e2.id = e1.dept_id)
```
**案例11** : 查询所有的部门信息, 并统计部门的员工人数
- 使用where筛选不同部门人数, 将子查询置于select字段后
```sql
select d.*, 
       (select count(*) from emp where emp.dept_id = d.id) '人数'  
from dept d;
```
**案例12** : 查询所有学生的选课情况, 展示出学生名称, 学号, 课程名称
- 多对多查询方式
```sql
select s.name, s.no, c.name 
from student s, course c, student_course sc  
where s.id = sc.studentid and c.id = sc.courseid;
```




