
### 题目


### 暴力解
- 思路: 使用二重循环依次验证
- 代码: 略

### 我的解
- 思路: 模拟滑动窗口
1. 如果当前滑动窗口内没有重复hash, 则试探
		(1) 如果试探值不重复, 则右扩
		(2) 如果仍重复, 则继续右滑
	2. 如果当前滑动窗口内有重复的hash, 则右滑

- 代码1(C)
```c
int lengthOfLongestSubstring(char* s) {
    int hash[256];
    int l = 1;
    int p = 0;

    for(int i = 0; i < 256; i++) hash[i] = 0;

    if(!s[0])
        return 0;
        
    /*
        1. 如果当前滑动窗口内没有重复hash, 则试探
            (1) 如果试探值不重复, 则右扩
            (2) 如果仍重复, 则继续右滑
        2. 如果当前滑动窗口内有重复的hash, 则右滑
    */
    hash[s[p]] ++;
    while(s[p+l]){
        // 1.利用for循环检测是否有重复hash
        bool hasRepeat = false;
        for(int i = 0; i < 256; i++) {
            if(hash[i] >= 2) {
                hasRepeat = true;
                break;
            }
        }
        // 2.如果有重复, 则直接右滑
        if(hasRepeat) {
            hash[s[p]] --;
            hash[s[p + l]] ++;
            p++;
        }
        // 3.如果hash表中没有重复
        else {
            // 试探 s[p+l] 是否存在
            // 3.1 存在, 右滑
            if(hash[s[p + l]] >= 1) {
                hash[s[p]] --;
                hash[s[p + l]] ++;
                p++;
            }
            // 3.2 不存在, 右扩
            else {
                hash[s[p + l]] ++;
                l++;
            }
        }
    }
    return l;
}
```

- 结果: 时间复杂度O(n), 空间复杂度O(n)
![image-20241230201931702](D:\Majinliang\Documents\笔记\算法\LeetCode\Inbox\image-20241230201931702.png)

### 最优解

##### 代码1(C)

```c
int lengthOfLongestSubstring(char* s) { 
	int left = 0, right = 0; 
	int max = 0; 
	int i,j = 0; 
	int samechar = 0; 
	for (i = 0; i < strlen(s); i++) { 
		if(left < right) { 
			samechar = 0; 
			for(j = left; j < right; j++) { 
				if (s[j] == s[right]) { 
					samechar = 1; 
					break; 
				} 
			} 
			if (samechar) { 
				left = j + 1; 
			} 
		} 
		max = max < (right - left + 1) ? (right - left + 1) : max; 
		right++; 
	} 
	return max; 
}
```

- 





##### 代码2(C++)

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        // 哈希集合，记录每个字符是否出现过
        unordered_set<char> occ;
        int n = s.size();
        // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动
        int rk = -1, ans = 0;
        // 枚举左指针的位置，初始值隐性地表示为 -1
        for (int i = 0; i < n; ++i) {
            if (i != 0) {
                // 左指针向右移动一格，移除前一个字符
                occ.erase(s[i - 1]);
            }
            while (rk + 1 < n && !occ.count(s[rk + 1])) {
                // 不断地移动右指针
                occ.insert(s[rk + 1]);
                ++rk;
            }
            // 第 i 到 rk 个字符是一个极长的无重复字符子串
            ans = max(ans, rk - i + 1);
        }
        return ans;
    }
};
```

- 思路分析
  - 从头开始循环, 没有重复元素, 则一直向后探寻, 直到遇到重复元素, 停下
  - 每次循环都把头元素从滑动窗口中删去, 删去后再一直向后探寻, 直到遇到重复元素
    - 通过这种方式, 终将重复元素从滑动窗口中挤出
  - 当滑动窗口最右侧到底时, 循环结束

![image-20241231002834908](D:\Majinliang\Documents\笔记\算法\LeetCode\Inbox\image-20241231002834908.png)