	**01背包问题**
N个物品和容量为V
第i个物品价格为vi, 价值是wi
每个物品只能使用一次
求背包可装的最高价值

## 二维动态规划
`f[i][j]`表示只看前i个物品, 总体积是j的情况下, 总价值最大是多少
`result = max{f[n][0~V]}`

1. 不选第i个物品, `f[i][j] = f[i-1][j]`
2. 选第i个物品, `f[i][j] = f[i-1][j - v[i]]`

`f[i][j] = max{1. 2.}`

`f[0][0] = 0;`

**代码**
```cpp
#include <iostream>
#include <cstring>
using namespace std;

const int N = 1010;

int n, m;
int f[N][N];
int v[N], w[N];

int main(){
	cin >> n >> m;
	for(int i = 1; i <= n; i++) 
		cin >> v[i] >> w[i];
	for(int i = 1; i <= n; i++) {
		for(int j = 0; j <= m; j++){
			f[i][j] = f[i - 1][j];
			if(j >= v[i]){
				f[i][j] = max(f[i][j], f[i-1][j - v[i]] + w[i]);
			}
		}
	}
	
	int res = 0;
	for(int i = 0; i <= N; i++) {
		res = max(res, f[n][i]);
	}
	
	cout << res << endl;
} 
```

### 优化

- 由代码可知, 计算最佳时, 只需要用到现有行和上一行, 不需要搞一个很大的二维数组
- 可以使用一维数组进行压缩, 只需要在更新时从后往前进行即可, 因为更新时只会用到左边的数据, 所以从右开始更新就可以只使用一个一维数组进行

#### 一维数组优化

```cpp
#include<iostream>
using namespace std;
const int N = 1010;
int n, m;
int f[N];
int v[N], w[N];

int main(){
	cin >> n >> m;
	for(int i = 1; i <= n; i++){
		cin >> v[i] >> w[i];
	}
	for(int i = 1; i <= n; i++ ){
		for(int j = m; j >= 0; j--){
			if(j >= v[i]){
				f[j] = max(f[j], f[j - v[i]] + w[i]);
			}
		}
	}
	cout << f[m] << endl;
} 
```

## dp解决背包问题

### 基础问题

1. 第一行, 物品编号为0, f必定为0, 因为前0个物品必定没有价值
2. 第一列, 背包容量为0, f也必定为0, 因为背包中装不进任何物品
![[算法/动态规划/Inbox/Pasted image 20240229152727.png]]
3. 从左上角开始看, 如果装不下编号1, 则结果与编号0一致
4. 向右移动, 如果装的下, 面临两个选择
	1. 不装这个物品, 则该位置的价值与上面的编号0最大价值一致
	2. 装入这个物品, 该位置的价值为减去去掉该物品体积后上一行表中位置的价值加该物品价值
5. 选取最大的价值作为该位置价值, 如果装的下, 则应该装进去
![[算法/动态规划/Inbox/Pasted image 20240229153236.png]]
6. 由此可得在只装一个编号或背包容量为2情况下所有取值相同
![[算法/动态规划/Inbox/Pasted image 20240229153324.png]]
7. 当可以往里装1号或2号中其中一个时, 判断应该装1号物品还是2号物品
	1. 谁的价值高, 就装谁
8. 依照这个规则得到背包内装物品的策略
![[算法/动态规划/Inbox/Pasted image 20240229153656.png]]

#### 解法归纳

1. 如果装不下当前物品, 那么前n物品最佳组合和前n-1物品最佳组合时一样的
2. 如果装得下当前物品
	1. 装当前物品, 在给当前物品预留了相应空间的情况下, 前n-1个物品的最佳组合加上当前物品的价值就是总价值
	2. 不装当前物品, 那么前n个物品和前n-1个物品的最佳组合是一样的
3. 选取两个假设中加大的价值作为最佳组合的价值

### 背包问题回溯

1. 先看右下角最大价值和同一列上一行价值是否相同, 不相同, 说明四号加入了背包
2. 给4号物品预留相应空间, 观察去掉预留空间后的价值
3. 看上一行价值是否一致, 一致则说明没有加入背包, 不需要预留空间
4. 依此类推, 得到背包中的全部物品

#### 归纳

从表的右下角开始回溯, 如果发现前n物品最佳组合价值和前n-1物品最佳组合价值一样, 说明第n个物品没有被装入, 否则就是装入了
