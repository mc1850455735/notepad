## 线程库的基本使用
- 头文件: `<thread>

**创建线程**

- 欲创建一个线程对象, 需要一个函数或者函数对象, 作为线程的入口。
- C++11 中，可以使用函数指针、函数对象或者 Lambda 表达式实现
- args 中传入参数列表
- 语法
```cpp
std::thread t(function_name, args...);
```
- 其中，args是传递给函数的参数列表

**等待线程**
- 如果主进程不等待其线程，执行完毕后直接结束，则可能导致程序报错。
- 使用 join() 函数检查对应的线程是否已经结束，如果未结束，那么停下来等待线程结束。
- 语法
```cpp
thread1.join();
```

**线程分离**
- 若是允许主进程结束后, 子线程仍然可以继续允许, 那么应该使用 detach() 函数
- 主进程结束后子线程仍然进行, 子线程中的内容可能无法输出 - 一般使用 join()
- 语法
```cpp
thread1.detach();
```

**判断线程**
- 使用 joinable() 函数判断一个线程是否可以 join, 该函数返回一个 bool 值类型


## 数据未定义错误

- **传递临时变量** - 用于构造线程的函数需要的参数和传递的不一致, 此时需要进行一些转化
	- 比如 `std::ref()` 将变量转为引用形式

- **传递指针或引用指向局部变量** - 若将一个局部变量的指针或引用传给了线程, 而随后变量又因生命周期结束而销毁, 这就导致在线程中指针或引用指向的变量无效。
	- 通过提高变量的生命周期解决

- **传递指针或引用指向已释放内存** - 类似于上个, 由于指向的内存已被释放, 其结果是未知的
	- 应在线程结束后再释放内存
	- 把 delete 写在 join() 后面

- **入口函数为类成员函数, 类对象被提前释放** - 类似上一个, 当线程试图使用类成员函数时, 类对象已经被释放, 从而不知道要使用什么函数
	- 使用智能指针
```cpp
// 创建一个指向MyClass类型的智能指针
std::shared_ptr<MyClass> a = std::make_shared<MyClass>();
std::thread t(&MyClass::myFun, a);
```

- **入口函数为类的私有函数**
	- 使用友元函数


## 互斥量解决多线程共享
- 如果多个线程中有共享数据的情况出现, 就要注意线程安全问题

**数据竞争**
- 如果多个线程同时访问同一个变量, 且至少有一个线程对变量进行了写操作, 那么就会出现**数据竞争**问题
- 为避免数据竞争, 需要使用同步机制确保多个线程之间对数据的访问是**安全的**

**互斥锁**
- 使用 `mutex` 头文件
- 使用 `std::mutex` 声明一个互斥锁
- 使用 `mutex.lock()` 加锁, `mutex.unlock()` 解锁
- 代码示例如下
```cpp
std::mutex mutex;
void fn() {
	mutex.lock();
	// 操作
	mutex.unlock();
}
```

**线程安全**
- **简单释义**: 如果多线程程序的运行结果每次都和单线程运行结果一致, 那么就称为线程安全的


## 互斥量死锁
( 略 )


## lock_guard & unique_lock

**lock_guard**
- 互斥量封装类, 用于保护共享数据, 防止多个线程同时访问同一资源导致数据竞争
- 特征: 
	- 当**构造函数**被调用时, 互斥量会被自动锁定
	- 当**析构函数**被调用时, 互斥量会被自动解锁
	- `std::lock_guard` 不能复制或移动 ( 源码中就对这两种操作进行了禁用 ), 只能在**局部作用域**中使用
- `lock_guard` 自动对其中 `mutex` 的状态进行加锁, 并在退出局部作用域, 调用析构函数时解锁
- 使用示例
```cpp
std::mutex mutex;
void fun(int& x) {
	std::lock_guard<std::mutex> lg(mutex);
	x += 1;
}
```

**unique_lock** ( 常用 )
- 互斥量封装类, 用于在多线程程序中对互斥量进行**更加灵活**的管理, 比如延迟加锁, 条件变量, 超时等
- 支持交换( swap )以及右值引用转换, 但是类似 lock_guard, 同样不能进行移动和复制
- 由于功能比 lock_guard 强大很多, 相应的, 开销也比 lock_guard 更大
- 成员函数
	- `lock()` : 尝试对互斥量进行加锁操作, 如果当前互斥量已经被其他线程持有, 则**阻塞等待**
	- `try_lock()` : 尝试对互斥量进行加锁, 如果当前互斥量被其他线程持有, 则返回false, 成功加锁则返回true
	- `try_lock_for(const std::chrono::duration<Rep, Period>& rel_time)` : 尝试对互斥量进行加锁, 如果当前互斥量被其他线程持有, 则阻塞等待, 直到成功加锁或者超过规定的等待期限时间
	- `try_lock_until(const std::chrono::time_point<Clock, Duration>& abs_time)` : 尝试对互斥量进行加锁, 如果当前互斥量被其他线程持有, 则阻塞等待, 直到成功加锁或到达指定的时间点 - ( 不常用 )
	- `unlock()` : 对互斥量解锁
- 同样的, `unique_lock` 也可以实现构造时默认加锁, 析构时解锁
- 使用示例1:
```cpp
std::mutex mutex;
int cnt;
void fn() {
	for (int i = 0; i < 100000; i++) {
		std::unique_lock<std::mutex> ul(mutex);
		cnt++;
	}
}
```
- 使用示例2 ( 加锁, 但是什么都不做 ) :
```cpp
std::mutex mutex;
int cnt;
void fn() {
	for (int i = 0; i < 100000; i++) {
		// 加锁但是什么也不做
		std::unique_lock<std::mutex> ul(mutex, std::defer_lock);
		ul.lock();
		cnt++;
	}
}
```
- 使用案例3 ( 延迟加锁 ) : 
```cpp
std::timed_mutex mutex;
int cnt;

void fn() {
	for (int i = 0; i < 2; i++) {
		// 创建 unique_lock 时默认不加锁, 等后续再加锁
		std::unique_lock<std::timed_mutex> ul(mutex, std::defer_lock);
		if (ul.try_lock_for(std::chrono::seconds(2))) {
			// 模拟处理时间
			std::this_thread::sleep_for(std::chrono::seconds(1));
			cnt++;
		}
	}
}
```


## call_once

**单例设计模式**
- 什么是单例设计模式 : 单例设计模式是一种常见的设计模式, 用于确保某个类只能创建一个实例;
- 由于单例实例是唯一的, 所以在多线程环境使用时, 应该考虑线程安全的问题

- 代码示例 ( 懒汉模式 )
```cpp
class Log {
private:
	static Log* log;
	Log() {}
public:
	Log(const Log& l) = delete;
	Log& operator=(const Log& l) = delete;

	static Log& getInstance() {
		if(log == nullptr)
			log = new Log();
		return log;
	}
};

static Log* Log::log = nullptr;   // 初始化
```

- 代码示例 ( 饿汉模式 )
```cpp
class Log {
private:
	static Log log;		// 饿汉模式
	Log() {}
public:
	Log(const Log& l) = delete;
	Log& operator=(const Log& l) = delete;

	static Log& getInstance() {
		return log;
	}
};
// 初始化静态实例
Log Log::log;
```

**拓展**
- 懒汉模式和饿汉模式都是单例模式的实现方式
- 懒汉模式的核心思想是**延迟初始化** , 即只在第一次使用单例对象时才创建实例 ; 通过这种方式, 可以在不使用单例对象是不创建对应对象, 从而节省了资源
- 饿汉模式的核心思想是**提前实例化** ，即在程序启动时就创建单例对象。由于实例化发生在程序初始化阶段，因此不需要担心**线程安全**问题

**std::call_once**
- 用于确保某个函数只会被调用一次
- 只能在线程中使用, 在main中调用会报错
- 函数声明如下
```cpp
template<class Callable, class... Args>
void call_once(std::once_flag& flag, Callable&& func, Args&&... args);
```
- 使用示例
```cpp
class Log {
private: 
	static Log* log;
	static void init();
	static std::once_flag once;
public:
	static Log& getInstance() {
		std::call_once(once, init);
		return *log;
	}
};
```


## condition_variable
- 头文件 `<condition_variable>`

**生产者消费者模型**
( 略 )

**使用步骤**
1. 创建一个 `std::condition_variable` 对象
2. 创建一个 `std::mutex` 互斥锁对象
3. 在需要等待条件变量的地方
	1. 使用 `std::unique_lock<std::mutex>` 锁定互斥锁
	2. 调用下列等待条件变量 ( 需要一个**已锁定**的互斥锁 )
		- `std::condition_variable::wait()` 
			- 如果没有谓词, 那么会释放互斥锁, 并等待一个notify
			- 如果有谓词, 那么会先检查谓词是否为true; 如果为true, 那么继续向下执行, 如果为false, 那么与没有谓词的情况相同。
		- `std::condition_variable::wait_for()` 
		- `std::condition_variable::wait_until` 
4. 使用下列函数通知等待的进程
	- `std::condition_variable::notify_one()`
	- `std::condition_variable::notify_all()`


## 线程池

- 线程的开辟和销毁开销相对都比较大，所以提前开辟一堆线程，以提高效率。
- 提前维护一个**线程数组**和一个**任务队列**，不停的指定线程池中的线程完成队列里的任务。
- 符合生产者与消费者模型。
- 详见此处 [08-01.cpp](D:\program\softwareProgram\CppProject\C++11%20Thread\08-01.cpp)


