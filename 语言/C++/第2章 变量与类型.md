## 基本内置类型

### 算数类型

**整型和布尔型**
|类型|含义|最小尺寸|
|-|-|-|
|bool|布尔类型|未定义
|char|字符|1B
|wchar_t|宽字符|2B
|char16_t|utf16字符|2B
|char32_t|utf32字符|4B
|short|短整型|2B
|int|整型|2B
|long|长整型|4B
|long long|长长整型(C++11)|8B
|float|单精度浮点型|6位有效数字
|double|双精度浮点型|10位有效数字
|long double|拓展精度浮点型|10位有效数字

**字符与整型**
- bool取值只有true和false
- char的大小与一个机器字节相同
- wchar_t保证可以存放机器最大拓展字符集中的任意一个字符
- int至少和short一样大, long至少和int一样大, long long至少和long一样大

**浮点型**
- C++标准指定了浮点数有效位数的最小值, 但是大多数编译器都实现了更高的精度
- 通常float以32bit表示
- 通常double以64bit表示
- 通常long double以96bit/128bit表示

##### 有符号与无符号类型
- 除去布尔型和拓展的字符型(wchar_t, char16_t, char32_t)以外, 其他类型都可以被分为有符号的和无符号的类型两种.
- 数值通常都是有符号的, 可以使用关键字unsigned使其变成无符号的;
	- unsigned int可以简写为unsigned
- 字符型可以被分为3种, char, signed char和unsigned char
	- char与signed char是不同的
	- 实际表现出来的char只有两种, 具体是哪一种由编译器决定
- 对于有符号数, 标准约定应该尽量实现正值与负值范围相近, 通常情况下编译器都将其设为类似于-128~127

**建议**
- 数值不为负, 选择无符号型
- 普通整数选用int
- 太大的整数选用long long, 因为通常long与int位数相同
- 算数表达式中**不要使用**char和bool表示值, 因为不同编译器中对其范围的规定不同
	- 如果需要使用char表示范围较小整数, 记得声明为signed char或unsigned char
- 浮点数运算选用double, 因为其精度更高且运算速度与float相近, 而float经常精度不够, long double通常精度提升有限且运行时消耗更大


### 类型转换

**类型所能表示的值的范围决定了转换的过程**
- 非布尔到布尔, 0为false, 非0为true
- 布尔到非布尔, false为0, true为1
- 浮点数到整数, 只保留小数点前部分
- 整数到浮点数, 小数部分记0
	- 如果整数大小超浮点数, 精度可能有损失
- 无符号数赋超范围值会取总大小模后余数
- 有符号数赋超范围值结果**未定义**

**建议**
- 应尽量避免依赖于环境的代码, 即在不同环境中结果不定的代码, 以保证程序的可移植性

#####  含无符号类型表达式
- 当一个算数表达式中既有有符号数又有无符号数, 在计算时会把他们全都化为无符号数进行计算
- 无符号数不会成为负数, 如果一个无符号数将成为负数, 那么就将其加无符号数的模, 直到值在范围内 - (补码)

**提示**
- 不要混用有符号类型和无符号类型
	- 因为其结果会因为不同机器变量类型所占位数的不同而变化

### 字面值常量
- 字面值常量的形式和值决定了它的数据类型

##### 整型和浮点型

**进制表示**
- 十进制, 八进制, 十六进制的开头 -> 无, 0, 0x
- 默认情况下
	- 十进制字面值类型时有符号的
	- 八进制和十六进制字面值可能是有符号, 也可能是无符号的
- 十进制字面值是int, long, long long在能容纳下的情况下尺寸最小的那个
- 八进制和十六进制是
	- int, unsigned int
	- long, unsigned long
	- long long, unsigned long long

**数值大小**
- 若字面值中没有一个能容纳的下, 则产生错误
- short没有对应的字面值
- 十进制没有实际上的负的字面值, 而是对正的字面值求负
- 浮点型字面值可以表示为一个小数或者科学计数法表达的指数
	- 0. / .2
	- 3.14e2, 1.0e0
- 默认的浮点类型是double

##### 字符和字符串字面值
- 单引号括起来的单个字符是char型字面量
- 双引号括起来的零个或多个字符是字符串型字面量
	- 字符串字面量实际上是由常量字符构成的数组, 编译器在每个字符串的结尾处添加一个空字符`\0`
	- 因此字符串的长度比他的实际内容数量多1个
- 如果两个字符串位置紧邻且只有空格, 缩进和换行分割, 则他们实际上是一个整体

##### 转义序列

**两类无法直接使用的字符**
- 不可打印的字符(如退格等)
- 在C++中有特殊含义的字符(如双引号, 换行符等)
	- 在这些情况下, 需要使用转义序列来打印字符
	- 转义序列以反斜线开始, C++中常见转义序列如下
		- 换行 -> `\n`
		- 回车符 -> `\r`
		- 横向制表 -> `\t`
		- 纵向制表 -> `\v`
		- 退格符 -> `\b`
		- 双引号 -> `\"`
		- 单引号 -> `\'`
		- 反斜线 -> `\\`
		- 问号 -> `\?`
		- 报警符 -> `\a`
		- 进纸符 -> `\f`
- 可以使用`\八进制`或`\x十六进制`来表示一个字符
	- 如果其解析影响了正常的书写, 可以使用合并字面字符串的方式避免编译器的误解
	- Windows中, 其编码为ASCII码

##### 指定字面值类型
- 通过在字面值前后增加对应的前缀或后缀, 可以改变字面值的默认类型

**字符与字符串(前缀)**
- u -> unicode16    => char16_t
- U -> unicode32    => char32_t
- L -> 宽字符          => wchar_t
- u8 -> UTF-8         => char

**整型与浮点型(后缀)**
- u或U -> unsigned
- l或L -> long/long double
- ll或LL -> long long
- f或F -> float

可以将他们合起来使用, 如ull表示unsigned long long

##### 布尔值和指针字面值
- 布尔字面值: true和false
- 指针字面值: nullptr

## 变量
对C++来说, 变量和对象一般可以互换使用

### 变量定义

基本形式: `<类型说明符> <变量名>[,变量名2,变量名3,...];`
定义时还可以为一个或多个变量**赋初值**

##### 初始值

变量在定义时被赋予了一个特定的值, 则称这个对象被初始化了
- C++中可以使用先定义的变量值初始化后定义的其他变量
	- 如int a = 0, b = a + 2; 是正确的
- C++中, 虽然都使用等号, 但是使用等号进行初始化和使用等号进行赋值是**完全不同**的两个操作

**注意**
初始化不是赋值, 初始化的含义是在创建变量时为其提供一个初值, 而赋值的含义是将当前变量中的值擦除, 写入一个新值

##### 列表初始化
- 在C++11中, 允许使用花括号对变量进行初始化
	- 例如 int a = {1}; int b{2};
- 用于内置类型的变量时, 如果该初始值存在丢失信息的风险, 那么编译器会直接报错

**示例**
```Cpp
long double ld = 3.1415926535
int a{ld}, b = {ld}; // 会报错
int c(ld), d = ld;   // 不会报错, 但是确实损失了信息
```

##### 默认初始化
- 如果定义了一个变量但是没有指定初始值, 那么变量将被默认初始化
- 变量将被赋予默认值, 默认值将由变量类型决定

**内置类型变量**
- **内置类型**变量未被显式初始化, 那么其初始值由定义的位置决定
- 定义于任何函数体外的内置类型变量被初始化为0
- 定义于任何函数体内的内置类型变量将**不被初始化**
	- 一个未被初始化的内置类型变量的值是**未定义的**
	- 拷贝以及其他形式的访问都将引发错误

**类的初始化**
- 每个类各自决定其初始化对象的方式
	- 包括是否允许不经初始化就定义对象
- 绝大多数类都支持不显式初始化而定义对象
	- 如string, 其默认初始化为空串
- 部分类要求必须进行显式初始化, 否则将产生错误

**建议**
建议初始化每一个内置类型的变量, 以保证程序的可靠性

### 变量声明与定义的关系
- C++允许分离式编程, 即把一个程序分成多个文件进行编写, 每个文件可以被独立编译
- 为支持分离式编程, C++把声明与定义区分开来
	- 声明使名字为程序所知, 文件想使用别处定义的名字, 则需要包含对那个名字的声明
	- 定义创建于名字相关联的实体
- 声明规定了变量的名字和类型, 而定义还会为其分配存储空间, 以及进行可能的初始化
- 如果想要声明一个变量而不定义它, 则使用关键字extern
	- 变量只能被定义一次, 但是可以被多次声明
- 如果想要多个文件使用一个变量, 则必须用到**声明与定义的分离**

### 标识符

- C++标识符由数字, 字母, 下划线构成, 不能以数字开头
- 长度没有限制, 大小写敏感

- 用户自定义标识符中
	- 不能出现连续两个下划线
	- 不能以下划线紧邻大写字母开头
	- 函数外标识符不能以下划线开头

##### 变量命名规范
- 标识符要体现实际意义
- 变量名用小写字母
- 类名以大写字母开头
- 多个单词之间以大写字母或下划线做分隔

### 名字的作用域

- 每个名字都会指向一个实体, 而不同位置的同一个名字可能指向不同的实体, 这由作用域决定
- C++中大多数作用域以花括号进行分隔
- 名字的有效区域始于名字的**声明语句**, 而结束于声明语句所在作用域的末端

**全局作用域与块作用域**
- 全局作用域: 定义于所有花括号以外的名字拥有全局作用域, 全局作用域的名字在整个程序内都可使用
- 块作用域: 在函数体内的名字, 作用域限定在函数体内, 拥有块作用域

##### 嵌套的作用域

- 被包含的作用域称为内层作用域
- 包含别的作用域的称为外层作用域
- 允许在内层作用域中**重新定义**外层作用域已有的名字
	- 函数内部不宜定义与全局变量同名的新变量
- 使用 **作用域运算符`::`** 来显式访问全局作用域(覆盖默认的作用域规则)

## 复合类型
- 复合类型是基于其他类型定义的类型
- 关于声明: 一条声明语句由一个基本数据类型和一个紧随其后的声明符列表组成

### 引用
- 引用为对象起了一个另外的名字, 引用类型引用另一种类型, 通过`&`来定义
- 定义引用时, 程序把引用和他的初始值**绑定**在一起, 而不是把初始值拷贝给引用
- 因此引用必须初始化, 无法在初始化后重新绑定新的变量

##### 引用即别名
- 引用只是为一个已存在的对象所起的另一个名字
- 因为引用本身不是一个变量, 所以无法定义引用的引用

##### 引用的定义
- 允许一条语句中定义多个引用, 每个引用以`&`开头
- 一句内的前一个定义可以作为后一个定义的右值
- 除特殊情况, 引用的类型要与之绑定的对象严格匹配
- 引用只能绑定在对象上, 而不能是字面值或常量表达式

### 指针
- 指针是指向另一种类型的复合类型
- 指针也实现了对其他对象的间接访问

**与引用的不同**
- 指针本身就是一个对象, 允许对指针的赋值和拷贝, 以及先后指向几个不同的对象
- 指针无需在定义时赋初值. 与其他内置类型变量相同, 如果在块作用域内定义的指针未初始化, 那么其值是不确定的
- 定义指针时, 前面加指针运算符`*`

##### 获取对象的地址
- 指针存放对象的地址, 想要获取对象的地址, 需要使用取址操作符`&`
- 引用不是对象, 没有实际的地址, 所以无法定义指向引用的指针
	- 指向引用实际上就是指向引用绑定的对象
- 除了某些特殊情况, 其他所有的指针类型都要和它所指向的对象严格匹配
	- 如果指向了其他类型, 那么对对象的操作将发生错误

##### 指针值

指针值只能是以下四种状态
- 指向一个对象
- 指向紧邻对象空间的下一个位置
- 空指针
- 无效指针

试图访问无效指针的值将发生错误, 编译器不负责检查此类错误, 所以要求程序员在使用指针时要小心谨慎

##### 使用指针访问对象

- 使用解引用符`*`访问指针指向的对象
- 给解引用的指针赋值, 实际上就是对这个对象进行赋值
- 解引用只适用于确实指向一个对象的指针

**注意**
- 使用`*`和`&`时, 要注意在不同的上下文下其有不同的含义, 要注意区分

##### 空指针




## 数组

与C语言中的数组类似, 声明方式为
`typeName arrayName[arraySize]

#### 数组初始化规则

1. 只能在定义时进行初始化
2. 可以使用下标进行单独的初始化

可以使用类似
`int totals[100] = {0}`
来将数组内所有元素都初始化为0(但是也只能初始化为0)

#### C++11中的数组初始化方法()
1. 初始化数组时, 可以省略等号( = )
2. 可以不在大括号内设置元素
3. 列表初始化不允许缩窄变换

## 字符串

字符串是以空字符结尾的一个字符数组

#### 字符串的拼接
在C++中, 可以使用空格, 回车符和制表符来对字符串常量进行拼接

---
#### 在数组中使用字符串
可以使用字符串来对字符数组进行初始化

对于字符串短于字符数组的情况, 字符数组多出来的部分将会被置为0

对于字符串长于字符数组的情况,  程序将会**报错**
而且在字符串赋给字符数组时,  需要把结尾的结束符也算进去

---
#### cin输入字符串的问题
- cin通过空白来确定字符串结束的位置, 使得cin只能获取一个单词
- cin输入的字符串可能比目标字符数组的长度要长, 导致溢出问题

---
#### 读取一行的字符串输入💯

cin提供了一些面向行的字符串输入, 以get()和getline()为例

1. getline()提供了一次读取一行的能力, 在读取完一行后, 拿走换行符, 并在字符串中使用空字符来替换换行符
	使用方法: cin.getline(数组名, 数组长度);
	函数最多读取 数组长度-1 个字符, 剩下的一个空间用来存储空字符.
	
2. get() 也可以一次读取一行, 但是读取完以后会将换行符留在缓冲区内, 下次继续调用如果不吸收回车符,  那么get()将**直接结束**
	使用方法: cin.get(数组名, 数组长度);
	
	读取完成后, 可以使用get()的重载格式来吸收回车符
	使用方法: cin.get();

**空行和其他问题**
**失效位**的设置 : 
1. 对get(), 读取到空行时, 会设置失效位
2. 对getline(), 没能拿走一行内全部字符时, 会设置失效位

当失效位被设置后, 输入将被阻断
可以使用**cin.clear();** 来恢复失效位

---
#### 字符串与数字的混合读取💯

当使用类似 cin >> num; 读取完数字以后, 要使用 **cin.get();** 来吸收回车符
否则, cin.getline() 或者 cin.get() 就会检测到回车符, 然后**停止输入**

## string类

string类是C++的推出的替代字符数组的变量类型, 他支持多种方便快捷的字符串处理函数.

**string对象和字符数组的区别是 :**
- 可以将string对象声明为简单的变量, 而不是以数组形式存在
- 程序能够自动处理string的大小

---
#### C++11风格字符串初始化

*四种字符串初始化方法*
```C++
char first_data[] = {"abc"};
char second_data[] {"abc"};
string third_data = {"abc"};
string four_data {"abc"};
```

---
#### string对象的赋值、拼接操作

- 可以直接将一个string对象赋给另一个string对象，而字符数组不能
- 可以使用str1 = str2 + str3; 或 str1 += str2 来实现字符串的拼接.

---
#### string类的其他操作

- str1.size() 返回字符串中的字符数

---
#### string类 IO

当一次性要读取一行而不是一个单词的时候, 所采用的句法与 字符数组 略有区别
```getline(cin, str1);```
(前面没有cin. 这个对象)

---
#### 其他字符串形式

1. wchar_t : L前缀
2. char16_t : u前缀
3. char32_t : U前缀

**原始字符串**
使用R在字符串前, 以+ * ( 作为字符串开始, )+* 作为 字符串结束
示例: `R"+*(asj$@*%^&*)+*"

前缀R可以与u或L等前缀一起使用

## 结构

C++结构可以**定义初始值**

结构可以将多个相同或不相同的元素整合到一起, 更加灵活.

C++允许在声明结构类型变量时省略struct关键字

通常应该对结构进行**外部声明**, 来让所有的函数都能够使用该结构类型

---
#### C++11风格结构初始化

student st1 {"majinliang", 18, 170};
不允许宽窄变换

---
#### 结构的成员赋值

使用赋值运算符=把一个结构赋值给另一个同类型的结构是, 编译器会自动地进行成员赋值, 即把等号右边结构体内的每个成员都一一赋给左边结构体相对应的成员,  即使左边的成员是数组

---
#### 结构中的位字段

C++中的结构体可以指定位字段来与底层的某些设备相契合, 写法如下
![[语言/C++/Inbox/Pasted image 20221209232642.png]]
在声明时, 结构体中没有对于变量名占位变量的可以忽略.
![[语言/C++/Inbox/Pasted image 20221209232752.png]]

以上

## 共用体

- 共用体的长度为其最大成员的长度.
- 共用体只能存储int, long, 或double
- 共用体只能同时存储其中的一种类型
- 一般用于嵌入式编程

## 枚举

在不进行强制类型转换的情况下, 只能将定义枚举时使用的枚举量赋给这种枚举的变量

- 枚举量可被提升为整数型变量, 但是int不能自动转换为枚举型
- 可以通过强制类型转换将int转换成枚举型

#### 枚举量值的定义

- 枚举量的值在不显式定义的情况下是从0开始逐个向后递增1
- 可以显式的定义部分或全部枚举量的值
- 可以创建多个值相同的枚举量

#### 枚举的取值范围

枚举取值范围的定义 : 
- 找出枚举值的最大值
- 找出大于这个枚举值的最小二次幂减1
- 得到的结果就是取值范围

## 指针和自由存储空间

- 指针是一个变量 , 他存储的是值的地址, 而不是值本身
- 可以通过new关键字和指针的结合来实现动态数组的声明

使用cout输出指针值是, 一般会以十六进制格式输出

使用 * 来使用指针内的值

#### 指针

###### 声明和初始化指针

使用 `变量名 * 指针名` 的格式来创建一个指向变量名类型的指针
```C++
int *p
```

###### 指针的危险

对于野指针指向变量的赋值, 是有危险的

###### 指针和数字

指针虽然以数字形式储存, 但指针并不是整数,  在某些编译器上,  直接将整数赋给指针类型可能会产生错误

如果需要将整数类型赋给指针类型,  需要用到强制转换

#### 动态分配内存

###### 使用new方法来分配内存

C++中使用new方法来分配内存 , 具体格式如下

*TypeName * pointName = new TypeName;* 

直接赋值 与 new方法创建内存空间赋值的区别
- 直接赋值创建的变量储存在栈中
- new方法创建的内存块储存在堆中

如果分配内存失败,  指针会被赋值成为null pointer

###### 使用delete来释放内存

C++中使用delete来释放**由new分配的**内存
如果不进行内存释放,  那么有可能会发生 内存泄漏

```C++
delete p
```

delete只会释放指针指向的内存,  并不会删除指针本身
再次释放已经释放过的指针所造成的结果是不确定的,  这通常是不安全的

然而,  释放空指针是安全的

#### 动态数组

- 如果在声明时创建数组, 数组的长度是确定的, 这种分配内存方式称为**静态联编**
- 在运行时选择数组的长度, 称为**动态联编**

###### 使用new创建动态数组

创建动态数组时, 只需要将元素的数量告诉new即可, 然后使用对应类型的指针来接收地址

`int * psome = new int[10];`

在释放时, 同样需要使用数组类型的释放方式

`delete[] psome; `

*对于数组类型, 创建和销毁都需要使用方括号[]*

使用new与delete关键字的一些规则
- 不要使用delete来释放不是由new创建的内存
- 不要使用delete释放同一个内存块两次
- 如果使用new[] 来为数组分配内存,  则应该使用delete[]来释放
- 如果使用new来为一个数组分配内存, 则应使用delete来释放
- 对空指针应用delete是安全的

###### 使用动态数组

只需要将指向内存块的指针当作是数组名使用即可

## 指针、数组和指针算数

多数情况下， C++将数组名解释为数组第一个元素的地址

指针允许加、减常数来实现指向数组内不同的元素
指向同一个数组的指针之间还可以通过减法计算指针之间相差的元素数

#### 指针和字符串

为cout提供字符串中某元素的地址值，那么cout将从这个元素开始打印，直到遇到字符串的末尾

- 某些编译器将字符串字面量视为只读变量

*应该使用strcpy()或strncpy()而不是赋值运算符来将字符串赋给数组*

#### 结构数组

略

#### 自动储存、静态储存和动态储存

- 自动储存 - 常规变量使用自动存储空间，被称为自动变量；自动变量是一个局部变量，通常储存在栈中
- 静态存储 - 两种声明静态存储的方法 - 1.在函数外面声明他们 2.使用关键字static
- 动态存储 - 使用new和delete管理的堆内存

## 类型组合

#### 关键字auto

使用关键字auto可以自动确认变量的类型

## 数组的替代品

#### 模板类vector

vector是一种动态数组， 可以在末尾或中间添加新元素
他是使用new手动创建动态数组的替代品

声明格式：
*vector< typeName > vt(n_elem)*
当n_elem为空时，vt的长度为0

#### 模板类array

array是一种静态数组，其效率与数组相同，但是更方便，更安全

*vector< typeName, n_elem > arr*
与vector不同的是,n_elem不能是变量

#### vector、array和数组

- 无论是数组、vector对象、array对象，都可以使用标准数组法来访问其中的每一个元素
- array和数组储存在栈中，而vector储存在堆中
- 可以将一个array对象赋值给另一个对象，而数组就必须逐个复制

- 对于vector和array，可以使用函数at()来代替下标索引，**防止越界**

