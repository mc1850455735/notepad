
## static修饰符

static表示静态, 是Java中的一个修饰符, 可以修饰成员方法, 成员变量

###### 静态变量

- 被该类所有对象共享
- 不属于对象, 属于类
- 随着类的加载而加载, 优先于对象存在

**调用方式**
- 类名调用(推荐)
- 对象名调用

###### static内存图
加载类时, 会在堆内存中单独开辟出一块**静态内存存储空间**(静态区)
当对静态变量进行赋值后, 内存区中才会有内容

静态变量是随着类的加载而加载的, 是优于对象出现的

![[语言/Java/Inbox/Pasted image 20221212141700.png]]



###### 静态方法

**特点**
- 多用在测试类和工具类中
- Javabean类中很少会用

**调用方式**
- 类名调用( 推荐 )
- 对象名调用

###### static注意事项

- 静态方法只能访问静态变量和静态方法
- 非静态方法可以访问静态变量和静态方法, 也可以访问非静态变量和非静态方法
- 静态方法中没有this关键字

- 在静态变量和方法被加载到内存后, 非静态变量和方法有可能还没有加载
	所以非静态变量或方法不能调用静态变量或方法
- 在非静态变量或方法被生成后, 静态变量和方法一定已经被加载完毕
	所以静态变量和方法能够调用非静态变量和方法

**this关键字**
this是由java虚拟机自动分配的一个关键字, 他表示的是调用当前方法的对象的地址值

在方法的声明里, 隐含一个this关键字的声明, 它是由虚拟机自动传参的, 不能手动进行
如果进行了显式声明, 也不会报错, 但是不能进行显式传参

![[语言/Java/Inbox/Pasted image 20221212154103.png]]

###### 工具类

帮助我们做一些事情, 但不描述任何事物的类

**类的分类**
- JavaBean类: 用来描述一类事物的类 - Student, Teacher, Dog, Cat等
- 测试类: 用来检查其他类是否书写正确,  **带有main方法**的类, 是程序的主入口
- 工具类: 不是用来描述一类事物, 而是用来做一些事情的类

**定义工具类的要求**
1. 类名见名知意
2. 私有化构造方法 - 因为工具类的对象没有任何意义 , 所以不允许创建该类对象
3. 方法定义为静态 - 方便调用

###### 重新认识main方法

- public - 被JVM调用, 访问权限足够大
- static - 被JVM调用, 不用创建对象, 直接**类名访问**
		因为main方法是静态的, 所以测试类的其他方法也要是**静态的**
- void - 被JVM调用, 不需要返回值
- main - 一个通用名称, 虽然不是关键字, 但是被JVM识别
- String[] args - 以前用来接收键盘数据, 现在没用, 但是为了向下兼容, java决定保留


## 继承

**面向对象三大特征**
- 封装 - 对象代表什么, 就得封装对应的数据, 并提供数据对应的行为
- 继承 - 我不道啊
- 多态 - 我不道啊

###### extends关键字

- Java中提供一个关键字extends, 使用这个关键字, 我们可以让一个类和另一个类建立起继承关系

![[语言/Java/Inbox/Pasted image 20221212210000.png]]
- Student称为**子类(派生类)**, Person称为**父类(基类或超类)**

###### 什么是继承

**使用继承的好处**
- 可以把多个子类中重复的代码抽取到父类中, 提高代码的复用性
- 子类可以在父类的基础上, 增加其他的功能, 使子类更强大

**继承需要学习的点**
- 自己设计
	- 什么时候用继承 - 当类与类之间**存在相同内容**而且满足**子类是父类中的一种**, 就可以考虑使用继承来优化代码
- 使用别人

###### 继承的特点

Java 中只支持单继承, 不支持多继承, 但是支持多层继承

- 单继承 - 一个子类只能继承一个父类
- 多继承 - 一个子类可以同时继承多个父类
- 多层继承 - 子类A继承父类B, 父类B继承父类C
	- 父类的父类称为间接父类
	- Java中的每一个类(即使是你自己建立的类)都直接或间接的继承于Object类

**继承体系**
![[语言/Java/Inbox/Pasted image 20221212212333.png]]

- 对于权限是private的属性或方法, 子类无法继承到
*子类只能访问到非私有的成员*

###### 子类对于父类继承的内存原理

![[语言/Java/Inbox/Pasted image 20221212225355.png]]

- 父类的构造方法不能被子类继承

带有继承结构的对象的调用
![[语言/Java/Inbox/Pasted image 20221212222010.png]]

**Java的垃圾处理器**
略

**private究竟能不能被继承**
对于带有private修饰的父类属性, 实际上子类是成功继承了下来的, 但是由于属性的private修饰, 导致无法访问到该属性

根据**Java内存调试器**的分析, 父类的私有属性值实际上是被子类继承了下来的

###### 成员方法的继承模式

**子类继承父类的方法的调用模式**

Java虚拟机在最顶层开始设立了一个虚方法表
*要求*
- 非private
- 非static
- 非final

基类会将虚方法表传递给继承类, 然后继承类再添加上属于自己的虚方法, 传递给继承类的继承类, 以此往复循环

![[语言/Java/Inbox/Pasted image 20221212223329.png]]

**只有父类中的虚方法才能被子类继承**

**内存原理 - 虚方法表**

![[语言/Java/Inbox/Pasted image 20221212223758.png]]


###### 继承的语法

**成员变量的访问特点**

***就近原则** : 谁离我近, 我就用谁*
- 如果一个子类中有一个变量和父类的变量名称相同, 那么在不做特殊处理的情况下, 变量名默认指的是子类中的那个变量;
- 如果某个变量名在子类中没有,  那么就会去父类中寻找

- this关键字 - 当前对象
- super关键字 - 父类对象

**如何查看间接父类**
不能查看

**成员方法的访问特点**

先在本类中查看方法,  如果没有,  再到父类中去查找
直接调用本类方法时,会有一个隐含的this关键字

###### 方法重写
当父类方法不能满足子类需求时, 就需要进行方法重写

**书写格式**
在继承体系中, 子类出现了与父类中一模一样的方法声明, 我们就称子类这个方法时重写的方法

**方法重写的本质**
在虚方法表传递的过程中, 如果发生了方法重写, 则会**覆盖**
![[语言/Java/Inbox/Pasted image 20221214130326.png]]

**方法重写注意事项和要求**
1. 重写方法的名称、形参列表必须与父类中的一致
2. 子类重写父类方法时，**访问权限**子类必须大于等于父类
3. 子类重写父类方法时，**返回值类型**子类必须小于等于父类
4. 只有被添加到虚方法表里的方法才能被重写
***重写方法尽量与父类保持一致***

**@Override重写注释**
1. @Override放在重写后的方法上, 校验子类重写时的语法是否正确
2. 加上注解后如果有红色波浪线, 表示语法错误
3. 建议重写方法都加@Override, 代码安全优雅

###### 继承中的构造方法

**继承构造方法的特点**
- 父类中的构造方法不会被子类继承
- 子类中所有的构造方法都会先访问父类中的无参构造, 再执行自己

**为什么会提前初始化父类**
- 子类在初始化时, 可能会用到父类中的数据, 如果父类没有完成初始化, 子类将无法使用父类中的数据
- 子类初始化之前, 一定要调用父类构造方法先完成父类数据空间的初始化

**怎么调用父类构造方法的**
- 子类构造方法的第一行语句默认是 : super(), 即使**不写也存在**, 而且必须在第一行
- 如果想要调用父类中的有参构造, 就必须**手动写super**进行调用

**继承中构造方法的访问特点**
- 子类不能继承父类的构造方法, 但是可以通过super调用
- 子类构造方法第一行, 有一个默认的super();
- 默认先访问父类中无参构造方法, 再执行自己
- 如果想要方法调用父类有参构造, 必须手动书写

###### this和super

- this - 理解为一个变量, 表示当前方法调用者的地址值
- super - 代表父类存储空间

如果使用this关键字调用了本类中的其他方法，那么就不会添加super()

![[语言/Java/Inbox/Pasted image 20221214140234.png]]
由内存图可知this也只是方法中的一个变量

## 多态

面向对象三大特征
- 封装 - 对象代表什么, 就封装对应的数据, 并提供数据对应的行为
- 继承 - 解决代码重复问题, 同时也是多态的前置条件
- 多态 - 子类对象同时也是父类对象的一种, 可以直接赋值给父类对象类型

同时, 传入函数作为父类使用的子类对象在调用方法时使用的是子类的方法

#### 概念

**什么是多态**
同种类型的对象表现出不同的形态

**多态的表现形式**
***父类类型 对象名称 = 子类类型;***

**多态的前提**
- 有继承关系
- 有父类引用指向子类对象
- 有方法重写

#### 多态调用成员的特点

- 变量调用 - 编译看左边, 运行也看左边
- 方法调用 - 编译看左边, 运行看右边

**对于变量调用**
会先到父类中查看是否存在该变量, 如果存在, 则程序正常编译
当使用该变量时, 该变量的值使用父类中规定的值

**对于方法调用**
会先到父类中查看是否存在该方法, 如果存在, 则程序正常编译
当方法被调用时, 会优先使用子类中重载过的方法, 如果不存在重载过的方法, 则使用父类中的方法

###### 多态调用成员的内存图解

![[语言/Java/Inbox/Pasted image 20221215121352.png]]

###### 多态的优势

- 在多态形式下, 右边对象可以实现解耦合, 便于维护和拓展
- 定义方法时, 使用父类方法作为参数, 可以接受所有子类对象, 体现多态的拓展性和可维护性

###### 多态的弊端

- 不能调用子类的特有方法
**解决方法:使用强制转化变回子类类型**

```C++
Animal a = new Dog();
Dog d = (Dog)a;
```

强制转换的时候必须要对应相应的类, 否则会抛出异常

#### 对象类型判断

###### 关键字instanceof

如果符合对应的类型, 则值为true
如果不符合对应的类型, 则值为false

###### JDK14新特性 - 判断与强转合并

![[语言/Java/Inbox/Pasted image 20221215123223.png]]

## 包

**什么是包**
包就是文件夹。用来管理各种不同功能的Java类，方便后期代码维护。

**包名的规则**
公司域名反写 + 包的作用，需要全部英文小写，见名知意(com.itheima.domain)

包名 + 类名 ==> 全类名 / 全限定名

**使用其他类的规则**
必须使用全类名, 即 包名.类名

**import关键字**
在Java中如果使用Student类, 则需要使用import导包来简化操作

- 使用同一个包中的类时,不需要导包
- 使用java.lang包中的类时,不需要导包
- 其他情况都需要导包
- 如果同时使用两个包中的相同类,需要使用全类名

## final关键字

- 修饰 方法 - 表明当前方法是最终方法,  不能被重写
- 修饰 类 - 表明该类是最终类,  不能被继承
- 修饰 变量 - 表明为常量,  不能被修改

**常量命名规则**
- 单个单词全部大写
- 多个单词全部大写, 单词与单词之间用下划线隔开

**注意事项**
- final修饰基本类型 - 变量存储的**数据值**不能发生改变
- final修饰引用类型 - 变量存储的**地址值**不能发生改变,  但是可以改变引用**指向的对象内部的值**

## 权限修饰符

- 控制一个成员能够被访问的范围
- 可以修饰成员变量, 方法, 构造方法, 内部类

![[语言/Java/Inbox/Pasted image 20221215144521.png]]


## 代码块

- 局部代码块 - 已过时
- 构造代码块
	写在成员变量位置的代码块, 可以抽取构造方法的共同点来创建构造代码块;  在创建对象时, 会先执行构造代码块, 再执行构造方法 ( 其实也已经过时了😥 )
- **静态代码块**
	格式：static{}
	特点：需要通过static关键字修饰，**随着类的加载而加载**，并且自动触发，只**执行一次**
	使用场景：在类加载需要进行数据初始化的时候

使用静态代码块可以保证代码块内代码真的只执行一次


## 抽象类

抽象关键字 - abstract

- 抽象方法
	将共性的行为抽取到父类后。
	由于每一个子类执行的内容是不一样的，所以在父类中不能取到具体的方法体。该方法就可以定义为**抽象方法**。
- 抽象类
	如果一个类中存在抽象方法，那么该类就**必须**声明为**抽象类**

**抽象方法的定义格式**
- public abstract 返回值类型 方法名(参数列表);
- public abstract class 类名{}

**注意事项**
- 抽象类不能实例化
- 抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类
- 可以有构造方法 - 给子类用的构造方法
- 抽象类的子类
	- 要么是重写抽象类中的所有子类
	- 要么是抽象类

###### 抽象类和抽象方法的意义

为了确保项目中方法重载的格式统一


## 接口

使用关键字interface定义, 关键字implements使用

###### 接口的概念

接口是对一类行为的抽象

**接口的定义与使用**

- 接口使用关键字interface来定义
	public interface 接口名{}
- 接口不能实例化
- 接口和类之间是实现关系，通过implements关键字表示
	public class 类名 implements 接口名{}
- 接口的子类
	- 要么重写接口中的所有抽象方法 - 常用
	- 要么是抽象类

**注意**
- 接口和类的关系，可以是单实现，也可以是多实现
	public class 类名 implements 接口1,接口2 {}
- 实现类可以在继承一个类的同时实现多个接口
	public class 类名 extends 父类 implements 接口名1,接口名2 {}

###### 接口中成员的特点

- 成员变量
	- 只能是常量
	- 默认修饰符 : public static final
- 构造方法 - 无
- 成员方法
	- JDK7以前 - 只能定义抽象方法, 默认修饰符 : public abstract
	- JDK8 - 接口中可以定义有方法体的方法
	- JDK9 - 接口中可以定义私有方法

###### 接口与类的关系

- 类和类的关系
	- 继承关系, 只能单继承, 不能多继承, 但是可以多层继承
- 类和接口的关系
	- 实现关系, 可以单实现, 也可以多实现, 还可以在继承一个类的同时实现多个接口
	- 在实现接口时, 需要将接口中的抽象方法全部重写
	- 如果多个接口实现时有重名方法, 那么**只需要重写一次**就可以
- 接口和接口的关系
	- 继承关系, 可以单继承, 也可以多继承

#### 接口小扩展

JDK8开始接口中新增的方法
- JDK7以前 : 接口中只能定义抽象方法.
- JDK8新特性 : 接口中可以定义有方法体的方法(默认, 静态)
- JDK9新特性 : 接口中可以定义私有方法

原因 - 接口的升级会导致接口的实现类全部报错

###### JDK8以后接口中新增的方法

- 允许在 接口中定义默认方法, 需要使用关键字default修饰
	作用 - 解决升级接口问题

接口中**默认方法**的定义格式
- 格式 - public default 返回值类型 方法名(参数列表) { }
- 范例 - public default void show() {}

**接口中默认方法的注意事项**
- 默认方法不是抽象方法, 所以**不强制被重写**.  但如果被重写,  重写时去掉default关键字
- public可以省略,  default不能被省略
- 如果实现了多个接口,  多个接口中存在相同名字的默认方法,  子类就必须对该方法进行重写
- **如果一个类一次实现多个接口且多个接口中存在重名的默认方法, 那么必须对默认方法进行重写**

**接口中的静态方法**
- 允许在接口中定义静态方法, 需要使用static修饰

接口中静态方法的定义格式
- 格式 : public static 返回值类型 方法名(参数列表) {}
- 范例 : public static void show() {}

**接口中静态方法注意事项**
- 静态方法不能被重写
- 静态方法只能通过接口名调用,  不能通过实现类名或者对象名调用
- public可以省略,  static不能省略

###### JDK9以后接口中新增的方法

**接口中私有方法的定义格式**
- 格式2 : private 返回值类型 方法名(参数列表) { }
- 范例1 : private void show() { }

给静态方法用的静态私有方法
- 格式2 : private static 返回值类型 方法名(参数列表) { }
- 范例2 : private static void method() { }

###### 接口的应用

1. 接口代表规则,  是行为的抽象.  想要让哪个类拥有一个行为,  就让这个类是相对应的接口.
2. 当一个方法的参数是接口时,  可以传递接口所有实现类的方法,  这种方式称之为**接口多态**

###### 适配器设计模式

**什么是设计模式**
设计模式时一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码的可靠性、程序的重要性。

新建一个==**类XXXAdapter**==，让这个类实现接口中的所有方法，但是只是空实现
然后让目标类继承中间类，需要哪个方法就重写中间类中的哪个方法
最后让中间的适配器设为抽象类，避免外界创建相应对象。

![[语言/Java/Inbox/Pasted image 20221216154752.png]]


## 内部类

类的五大成员
- 属性
- 方法
- 构造方法
- 代码块
- 内部类

#### 内部类概念

**什么是内部类**
在类的里面再创建一个类

**什么时候用到内部类**
- 内部类表示的事物是外部类的一部分
- 内部类单独出现没有任何意义

**内部类的访问特点**
- 内部类可以直接访问外部类成员，包括私有
- 外部类要访问内部类成员，**必须创建对象**

#### 内部类分类

- 成员内部类
- 静态内部类
- 局部内部类
- 匿名内部类

###### 成员内部类

**成员内部类如何书写**
- 写在成员位置的，属于外部类的成员
- 成员内部类可以被一些修饰符所修饰, 比如 : private, 默认, protected, public等
- 在成员内部类里面, 在JDK16前不能定义静态变量, JDK16开始可以定义静态变量

**获取成员内部类对象**
1. 在外部类中编写方法, 对外提供内部类对象
2. 直接创建格式 : 外部类名.内部类名 对象名 = 外部类对象.内部类对象 ( 不推荐 )
	- Outer.Inner oi = new Outer().new Inner();

**成员内部类获取外部类成员变量**

成员内部类加载的**内存图**
![[语言/Java/Inbox/Pasted image 20221216170536.png]]

内部类中存在一个隐含的指向外部类的指针this
使用 外部类名.this.变量名 来获取外部类变量

###### 静态内部类
在默认内部类之前加关键字static

- 静态内部类也是成员内部类中的一种
- 静态内部类只能访问外部类中的静态变量和静态方法
- 如果想要访问非静态,  则需要创建对象

**创建静态内部类对象的格式**
外部类名.内部类名 对象名 = new 外部类名.内部类名()

- **调用非静态方法的格式**
	- 先创建对象, 使用对象来调用
- **调用静态方法的格式**
	- 外部类名.内部类名.方法名();

###### 局部内部类

1. 将内部类定义在**方法里面**就叫做局部内部类,  **类似**方法里的**局部变量**
2. 外界无法直接使用,  需要在方法内部创建对象使用
3. 该类可以**直接访问外部类成员**, 也可以访问**方法内的局部变量**

###### 匿名内部类💯
本质上就是隐藏了名字的内部类,  可以写在成员位置,  也可以写在局部位置

**格式**
```Java
new 类名或接口名() {
	重写方法;
}
```

**实现过程**
![[语言/Java/Inbox/Pasted image 20221216175258.png]]

**应用场景**
简化操作, 减少了变量的创建
![[语言/Java/Inbox/Pasted image 20221216180951.png]]

