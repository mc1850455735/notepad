
**简介**
- 串口是一种应用十分广泛的通讯接口, 串口成本低, 容易使用, 通信线路简单, 可以实现两个设备之间的相互通信
- 单片机的串口可以使单片机与单片机, 单片机与电脑, 单片机与各个模块之间相互通信, 极大拓展了单片机应用范围, 增强了单片机系统的硬件能力
- 51单片机内部自带UART(Universal Asynchronous Receiver Transmitter, 通用异步收发器) , 可以实现单片机的串口通信

**电路连接**
- 简单双向串口通信有两根通信线 (发送端TXD和接收端RXD) , TXD和RXD交叉连接
- 当只需要单向数据传输时, 可以直接连接一根通信线
- 当电平标准不一致时, 需要加电平转换芯片
![[硬件/STC89C51/Inbox/Pasted image 20240702180740.png]]

**电平标准**
- 电平标准是数据1和数据0的表达方式, 是传输线缆中人为规定的电压与数据的对应关系, 串口常用的电平标准如下三种
	- TTL : +5V表示1, 0V表示0
	- RS232电平 : `-3` ~ `-15V` 表示1, `+3` ~ `+15V`表示0
	- RS485电平 : 两线压差 `+2` ~ `+6V` 表示1, `-2` ~ `-6V` 表示0 (差分信号)

**常见通信接口比较**

|名称|引脚定义|通信方式|特点|
|-|-|-|-|
|UART|TXD,RXD|全双工,异步|点对点通信|
|I2C|SCL,SDA|半双工,同步|可挂载多个设备|
|SPI|SCLK,MOSI,MISO,CS|全双工,同步|可挂载多个设备|
|1-Wire|DQ|半双工,异步|可挂载多个设备|
- 此外还有CAN , USB等

**STC89C51中的UART**
- 其中有一个UART
- 四种工作模式
	- 模式0 : 同步移位寄存器
	- 模式1 : 8位UART, 波特率可变 (常用)
	- 模式2 : 9位UART, 波特率固定
	- 模式3 : 9位UART, 波特率可变
- 51单片机中的串口通信端口为P30与P31

**串口参数及时序图**
- 波特率 : 串口通信的速率 (发送和接收各数据位的间隔时间)
- 检验位 : 用于数据验证
	- 奇校验, 偶校验, 1校验, 0校验
- 停止位 : 用于数据帧间隔
![[硬件/STC89C51/Inbox/Pasted image 20250413224732.png]]

**串口模式图**
- 该串口模式图中的电路存在于单片机内部
- SBUF : 串口数据缓存寄存器, 物理上是两个独立的寄存器, 但占用相同的地址; 写操作时, 写入的是发送寄存器, 读操作时, 读出的是接收寄存器
- 串口靠定时器的溢出速率, 控制收发器的采样时间, 来约定传输速率
- 当发送数据或接收数据时, 会申请中断(TI与RI)
	- TI与RI占用同一个中断通道, 应在中断函数中判断是发送中断函数还是接收中断函数
![[硬件/STC89C51/Inbox/Pasted image 20250413225423.png]]
![[硬件/STC89C51/Inbox/Pasted image 20250414082808.png]]


### 串口相关寄存器
- SCON (Serial Control, 串行控制寄存器) :
	- SM0/FE (Serial Mode/Frame Error) : 当PCON中SMOD0位为1时, 为FE, 用于帧错误检测, 当检测到一个无效停止位时, UART接收器设置该位为1, 必须由软件清零; 当SMOD0位为0时, 为SM0, 和SM1配合完成串行通信工作方式的指定
	- SM1 : 与SM0配合
	- SM2 : 略
	- REN (Receive Enable) : 允许/禁止串行接收控制位, 软件置位; REN = 1, 则允许串行接收, 可启动串行接收器RxD; REN = 0, 则禁止接收
	- TB8 (Transmit Bit 8) : 在方式2,3中, 为要发送的第九位数据, 由软件置位
	- RB8 (Receive Bit 8) : 在方式2,3中, 为接收到的第九位数据; 在方式1中, 若SM2 = 0, 则为接收到的停止位; 方式0不用RB8
	- TI (Transmit Interrupt) : 由内部硬件自动置位1向主机请求中断, 中断响应后**必须由软件复位**
	- RI (Receive Interrupt) : 同上 
- PCON (Serial Control, )
	- SMOD (Serial Mode Double, 串行模式倍速): 波特率选择位, 软件置位, 默认为0; 当SMOD=0时, 所有串行工作方式的波特率都加倍; 当SMOD=1时, 只有串行工作方式1,2,3的波特率加倍
	- SMOD0 (Serial Mode 0 Control, 串行模式控制): 帧错误检测控制有效位, 为1时, SM0/FE 为帧错误检测
![[硬件/STC89C51/Inbox/Pasted image 20250414084529.png]]

**串行通信工作方式**
- 由SM0与SM1共同指定
- 当SM0与SM1分别为以下时
	- 00 : 方式0 -> 同步移位串行方式: 移位寄存器, 波特率为SYSclk / 12
	- 01 : 方式1 -> 8位UART, 波特率可变, 为`(2^SMOD) / 32 * (定时器1溢出率)`
	- 10 : 方式2 -> 9位UART, 波特率为`(2^SMOD) / 64 * SYSclk时钟频率`
	- 11 : 方式3 -> 9位UART, 波特率可变, 为`(2^SMOD) / 32 * (定时器1溢出率)`

**串口波特率配置**
- 串口波特率由T1定时器产生, 使用8位自动重装工作模式
- TL1负责计时, TH1负责自动重装
- 相关波特率可以在波特率计算器中直接计算
![[硬件/STC89C51/Inbox/Pasted image 20250414150814.png]]

**波特率计算过程**
- 以TL=0xFD为例, 每3us溢出一次
- 1/3us = 0.33333...MHz
- 若SMOD=0, 则波特率 / 2, 则0.33333...MHz / 16 / 2 = 0.020833...MHz / 2 = 0.0104166...MHz
- 0.0104166...MHz = 10,416.6Hz
- 10,416.6Hz * (11.0952 / 12) = 9600Mz

**代码示例**
- 初始化
```c
void UartInit(void)		//9600bps@11.0592MHz
{
	PCON &= 0x7F;		//波特率不倍速
	SCON = 0x50;		//8位数据,可变波特率
	TMOD &= 0x0F;		//设置定时器模式
	TMOD |= 0x20;		//设置定时器模式
	TL1 = 0xFD;		//设置定时初始值
	TH1 = 0xFD;		//设置定时重载值
	ET1 = 0;		//禁止定时器1中断
	TR1 = 1;		//定时器1开始计时
	ES = 1;     // 串口相关中断
	EA = 1;
}
```
- 发送
```c
void UART_SendByte(unsigned char byt) {
	SBUF = byt;      // UART发送只需要向SBUF中写数据
	while(TI == 0);
	TI = 0;
}
```
- 接收
```c
unsigned char dat;
void UART_Receive() interrupt 4{
	// 接收中断
	if(RI == 1) {
		dat = SBUF;
		RI=0;
	}
}
```


